export declare namespace TS {
    /**
    * @class TS.Exception
    *
    * @description The base class of all exceptions defined in this framework. The Exception class has a public read only
    *  property called 'type' which returns the fully qualified type name of the exception class. This way you are able
    *  to create a finer granular error handling based on the exception type. Your are not longer forced to parse the
    *  error message string to infer the nature of the exception. Each subclass of the Exception class has to override
    *  the 'type' property to reflect the own type. The exception class has also a read only 'innerException' property
    *  which allows to create an exception stack which links back to the root exception.
    *
    * @implements {Error}
    */
    class Exception implements Error {
        /**
        * @private
        */
        private internalMessage;
        /**
        * @private
        */
        private internalInnerException;
        /**
        * @description Returns the inner exception if available or null.
        *
        * @public
        *
        * @get {TS.Exception | null} innerException
        */
        readonly innerException: TS.Exception | null;
        /**
        * @description The error message.
        *
        * @implements {Error}
        *
        * @get {string} message
        */
        readonly message: string;
        /**
        * @description The error name. It's the same as the type.
        *
        * @implements {Error}
        *
        * @get {string} name
        */
        readonly name: string;
        /**
        * @description Returns the fully qualified type name of the exception.
        *
        * @public
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: TS.Exception);
        /**
        * @description Returns a combination of the 'type' and 'message' of the exception as string.
        *
        * @override {Object}
        *
        * @returns {string}
        */
        toString(): string;
        /**
        * @description Returns a string which is the concatenation of the 'toString' call results of the current exception and the inner exceptions.
        *  Call this function without any arguments on the top exception of the exception chain.
        *
        * @param {TS.Exception} exception
        * @param {boolean} isInner, Defaults to false
        * @param {string} offset, A string which is used to indent inner exception messages. Default to 2 spaces.
        *
        * @returns {string}
        */
        stackTrace(exception?: TS.Exception, isInner?: boolean, offset?: string): string;
    }
    /**
    * @class TS.AmbiguousResultException
    *
    * @description This exception signals a an error where an operation which is specified to deliver a single result
    *  fails because there are multiple possible results available.
    *
    * @extends {TS.Exception}
    */
    class AmbiguousResultException extends TS.Exception {
        /**
        * @private
        */
        private internalArgumentName;
        /**
        * @private
        */
        private internalArgumentValue;
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @description The name of the argument which caused the exception.
        *
        * @get {string} argumentName
        */
        readonly argumentName: string;
        /**
        * @description The value of the argument which caused the exception.
        *
        * @get {any} argumentValue
        */
        readonly argumentValue: any;
        /**
        * @constructor
        *
        * @param {string} argumentName, The name of the argument which caused the exception.
        * @param {any} argumentValue, The value of the argument which caused the exception.
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(argumentName: string, argumentValue: any, message?: string, innerException?: Exception);
    }
    /**
    * @class TS.ArgumentException
    *
    * @description This exceptions signals a general error caused by an invalid argument.
    *
    * @extends {TS.Exception}
    */
    class ArgumentException extends TS.Exception {
        /**
        * @private
        */
        private internalArgumentName;
        /**
        * @private
        */
        private internalArgumentValue;
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @description The name of the argument which caused the exception.
        *
        * @get {string} argumentName
        */
        readonly argumentName: string;
        /**
        * @description The value of the argument which caused the exception.
        *
        * @get {any} argumentValue
        */
        readonly argumentValue: any;
        /**
        * @constructor
        *
        * @param {string} argumentName, The name of the argument which caused the exception.
        * @param {any} argumentValue, The value of the argument which caused the exception.
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(argumentName: string, argumentValue: any, message?: string, innerException?: Exception);
    }
    /**
    * @class TS.ArgumentNullException
    *
    * @description This exception signals an error caused by an unexpected null value in an argument.
    *
    * @extends {TS.ArgumentException}
    */
    class ArgumentNullException extends TS.ArgumentException {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} argumentName, The name of the argument which caused the exception.
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(argumentName: string, message?: string, innerException?: Exception);
    }
    /**
    * @class TS.ArgumentNullOrUndefinedException
    *
    * @description This exceptions signals an error caused by an unexpected undefined or null value in an argument. The
    *  argument value of that exception will always be null and doesn't reflect the exact argument value which caused
    *  this exception.
    *
    * @extends {TS.ArgumentException}
    */
    class ArgumentNullOrUndefinedException extends TS.ArgumentException {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} argumentName, The name of the argument which caused the exception.
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(argumentName: string, message?: string, innerException?: Exception);
    }
    /**
    * @class TS.ArgumentNullUndefOrEmptyException
    *
    * @description This exception signals an error caused by an unexpected undefined or null value in an argument or
    *  an unexpected emptiness for an argument like an empty string or array. The argument value of that exception
    *  will always be null and doesn't reflect the exact argument value which caused this exception.
    *
    * @extends {TS.ArgumentException}
    */
    class ArgumentNullUndefOrEmptyException extends TS.ArgumentException {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} argumentName, The name of the argument which caused the exception.
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(argumentName: string, message?: string, innerException?: Exception);
    }
    /**
    * @class TS.ArgumentNullUndefOrWhiteSpaceException
    *
    * @description This exceptions signals an unexpected emptiness of a string. The argument value of that exception
    *  will always be null and doesn't reflect the exact argument value which caused this exception.
    *
    * @extends {TS.ArgumentException}
    */
    class ArgumentNullUndefOrWhiteSpaceException extends TS.ArgumentException {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} argumentName, The name of the argument which caused the exception.
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(argumentName: string, message?: string, innerException?: Exception);
    }
    /**
    * @class TS.ArgumentOutOfRangeException
    *
    * @description This exceptions signals that an argument exceeded the range of allowed values.
    *
    * @extends {TS.ArgumentException}
    */
    class ArgumentOutOfRangeException extends TS.ArgumentException {
        /**
        * @override {TS.ArgumentException}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} argumentName, The name of the argument which caused the exception.
        * @param {any} argumentValue, The value of the argument which caused the exception.
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(argumentName: string, argumentValue: any, message?: string, innerException?: Exception);
    }
    /**
    * @class TS.ArgumentUndefinedException
    *
    * @description This exceptions signals an error caused by an unexpected undefined value in an argument.
    *
    * @extends {TS.ArgumentException}
    */
    class ArgumentUndefinedException extends TS.ArgumentException {
        /**
        * @override {TS.ArgumentException}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} argumentName, The name of the argument which caused the exception.
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(argumentName: string, message?: string, innerException?: Exception);
    }
    /**
    * @class TS.IndexOutOfRangeException
    *
    * @description This exceptions signals that an index value exceeded the range of indexable elements.
    *
    * @extends {TS.Exception}
    */
    class IndexOutOfRangeException extends TS.Exception {
        /**
        * @get {string} type
        * @public
        * @override {TS.Exception}
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.InvalidInvocationException
    *
    * @description This exceptions signals that a function was invoked in an unexpected or invalid way.
    *
    * @extends {TS.Exception}
    */
    class InvalidInvocationException extends TS.Exception {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.InvalidOperationException
    *
    * @description This exceptions signals an attempt to start an operation which was not allowed to start in the current
    *  situation.
    *
    * @extends {TS.Exception}
    */
    class InvalidOperationException extends TS.Exception {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.InvalidCastException
    *
    * @description This exceptions signals that a casting operation failed.
  
    * @extends {TS.Exception}
    */
    class InvalidCastException extends TS.Exception {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.InvalidFormatException
    *
    * @description This exceptions signals that an operation failed because of an invalid format of some data.
    *
    * @extends {TS.Exception}
    */
    class InvalidFormatException extends TS.Exception {
        /**
        * @private
        */
        private internalArgumentName;
        /**
        * @private
        */
        private internalArgumentValue;
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @description The name of the argument which caused the exception.
        *
        * @get {string} argumentName
        */
        readonly argumentName: string;
        /**
        * @description The value of the argument which caused the exception.
        *
        * @get {string} argumentValue
        */
        readonly argumentValue: any;
        /**
        * @constructor
        *
        * @param {string} argumentName, The name of the argument which caused the exception.
        * @param {any} argumentValue, The value of the argument which caused the exception.
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(argumentName?: string, argumentValue?: any, message?: string, innerException?: Exception);
    }
    /**
    * @class TS.InvalidTypeException
    *
    * @description This exceptions signals that an argument has an invalid type.
    *
    * @extends {TS.Exception}
    */
    class InvalidTypeException extends TS.Exception {
        /**
        * @private
        */
        private internalArgumentName;
        /**
        * @private
        */
        private internalArgumentValue;
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @description The name of the argument which caused the exception.
        *
        * @get {string} argumentName
        */
        readonly argumentName: string;
        /**
        * @description The value of the argument which caused the exception.
        *
        * @get {string} argumentValue
        */
        readonly argumentValue: any;
        /**
        * @constructor
        *
        * @param {string} argumentName, The name of the argument which caused the exception.
        * @param {any} argumentValue, The value of the argument which caused the exception.
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(argumentName?: string, argumentValue?: any, message?: string, innerException?: Exception);
    }
    /**
    * @class TS.ArithmeticException
    *
    * @description This exception signals an errors in an arithmetic, casting, or conversion operation.
    *  ArithmeticException is the base class for DivideByZeroException, NotFiniteNumberException, and OverflowException.
    *  Use one of the derived classes of ArithmeticException if appropriate to the exact nature of the error.
    *  Throw an ArithmeticException if there is no appropriate subclass to describe the nature of the error.
    *
    * @extends {TS.Exception}
    */
    class ArithmeticException extends TS.Exception {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.OverflowException
    *
    * @description This exception signals that an arithmetic, casting, or conversion operation results in an overflow.
    *
    * @extends {TS.ArithmeticException}
    */
    class OverflowException extends ArithmeticException {
        /**
        * @override {TS.ArithmeticException}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.DividedByZeroException
    *
    * @description This exception signals an attempt to divide a number value by zero.
    *
    * @extends {TS.ArithmeticException}
    */
    class DividedByZeroException extends ArithmeticException {
        /**
        * @override {TS.ArithmeticException}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.NotFiniteNumberException
    *
    * @description This exception signals an attempt to execute an arithmetic operation with a number value which is
    *  either infinite or Not-a-Number (NaN).
    *
    * @extends {TS.ArithmeticException}
    */
    class NotFiniteNumberException extends ArithmeticException {
        /**
        * @override {TS.ArithmeticException}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.NotImplementedException
    *
    * @description This exception signals that a function or class is not or not fully implemented and can't be used.
    *
    * @extends {TS.Exception}
    */
    class NotImplementedException extends TS.Exception {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.DeprecatedException
    *
    * @description This exception signals that a function or class should not longer be used.
    *
    * @extends {TS.Exception}
    */
    class DeprecatedException extends TS.Exception {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.DirectoryNotFoundException
    *
    * @description This exception signals if the file system is not able to locate the requested directory.
    *
    * @extends {TS.Exception}
    */
    class DirectoryNotFoundException extends TS.Exception {
        /**
        * @private
        */
        private internalArgumentName;
        /**
        * @private
        */
        private internalArgumentValue;
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @description The name of the argument which caused the exception.
        *
        * @get {string} argumentName
        */
        readonly argumentName: string;
        /**
        * @description The value of the argument which caused the exception.
        *
        * @get {string} argumentValue
        */
        readonly argumentValue: any;
        /**
        * @constructor
        *
        * @param {string} argumentName, The name of the argument which caused the exception. Typically the name of a directory variable.
        * @param {any} argumentValue, The value of the argument which caused the exception. Typically the value of a directory variable.
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(argumentName?: string, argumentValue?: string, message?: string, innerException?: Exception);
    }
    /**
    * @class TS.BufferOverrunException
    *
    * @description This exception signals if the file system is not able to locate the requested directory.
    *
    * @extends {TS.Exception}
    */
    class BufferOverrunException extends TS.Exception {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.EnvironmentNotSupportedException
    *
    * @description This exception that some operation failed because the current environment is not supported. That may
    *  be the reason if a JavaScript VM lacks some functions, a Node.js script is running in a browser or vice versa or
    *  the operation system is not supported.
    *
    * @extends {TS.Exception}
    */
    class EnvironmentNotSupportedException extends TS.Exception {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
    * @class TS.TimeoutException
    *
    * @description This exception if thrown if a function or operation doesn't response in a timely manner.
    *
    * @extends {TS.Exception}
    */
    class TimeoutException extends TS.Exception {
        /**
        * @override {TS.Exception}
        *
        * @get {string} type
        */
        readonly type: string;
        /**
        * @constructor
        *
        * @param {string} message?, An optional message string.
        * @param {Exception} innerException?, An optional inner exception.
        */
        constructor(message?: string, innerException?: Exception);
    }
    /**
     * @description The module 'Utils' hosts a collection of functions which offer solutions for common problems or
     *  reoccurring tasks which are not class specific. Since they are not class specific, they are also not part of a
     *  class. They are simply collected in this file and are part of the namespace. You can consider all of this
     *  functions as static if you like, because you can call them without a prior instantiation of an object.
     */
    namespace Utils {
        /**
        * @interface ICurrency
        */
        interface ICurrency {
            Name: string;
            Code: string;
            Symbol: string;
        }
        /**
         * @description An array of currencies as defined in ISO 4217
         *
         * @see {@link http://www.iso.org/iso/home/standards/currency_codes.htm | ISO}
         */
        const currencyArray: Array<ICurrency>;
        /**
        * @description Searches for all occurrences of 'searchString' in 'sourceString' and returns an array of the
        *  indexes where the search string occurred in the sourceString.
        *
        * @param {string} sourceString
        * @param {string} searchString
        *
        * @returns {Array<number>}, An array of indexes where the searchString occurred in the sourceString.
        */
        function allIndexOf(sourceString: string, searchString: string): Array<number>;
        /**
        * @description Converts a bit string into an array of byte values. The function throws an exceptions if the
        *  value of argument 'bitString' is not a valid bit string.
        *
        * @param {string} bitString, The bit string to convert.
        *
        * @returns {Array<number>}, The resulting byte value array which may be empty.
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.ArgumentNullUndefOrWhiteSpaceException}
        * @throws {TS.InvalidTypeException}
        */
        function bitStringToByteArray(bitString: string): Array<number>;
        /**
        * @description Converts the values of the elements in argument 'byteArray' into a bit string representation.
        *
        * @param {Array<number>} unsignedByteArray, The array of byte values to convert.
        *
        * @returns {string}, The resulting bit string.
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException }
        */
        function byteArrayToBitString(unsignedByteArray: Array<number>): string;
        /**
        * @description Converts an array of unsigned byte values into an unsigned integer value. The function throws an
        *  exception if the value in argument 'unsignedByteArray' is not a valid byte array or empty. The function throws
        *  a 'TS.ArgumentOutOfRangeException' if the conversion exceeds the maximum number range. (Number.MAX_SAFE_INTEGER)
        *
        * @params {Array<number>} byteArray, An array of unsigned byte values.
        *
        * @returns {number}, The result value as unsigned integer.
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException }
        * @throws {TS.ArgumentOutOfRangeException}
        */
        function byteArrayToUInt(unsignedByteArray: Array<number>): number;
        /**
        * @description Converts the value given in argument 'unsignedByteValue' into an 8 character bit string. The result
        *  string will be padded with leading '0' characters if necessary until the length of 8 characters is reached.
        *
        * @param {number} unsignedByteValue, Has to be an unsigned byte value.
        *
        * @returns {string}, The 8 character bit string representation of the value.
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function byteToBitString(unsignedByteValue: number): string;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is an ArrayLike type. Trows a
        *  'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkArrayLikeParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is an array. Throws a 'TS.InvalidTypeException' if no.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkArrayParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the argument 'parameter' is a valid string. Throws a 'TS.InvalidTypeException' if not. Checks
        *  whether the argument 'parameter' is an empty string or whitespace only. Throws a
        *  'TS.ArgumentNullUndefOrWhiteSpaceException' if so. Check whether the argument 'parameter' is a valid binary
        *  string. (A string which comprises the characters '[0,1]' only, with no white space.) Throws a
        *  'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {string} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.ArgumentNullUndefOrWhiteSpaceException}
        * @throws {TS.InvalidTypeException}
        */
        function checkBitStringParameter(parameterName: string, parameter: string, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is a boolean. Throws a 'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkBooleanParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the 'thisContext' is a valid type for a constructor call or not. Throws a
        *  'TS.InvalidOperationException' if the value of argument 'thisContext' is either null or undefined or not of the
        *  required type. Throws a 'TS.ArgumentNullOrUndefinedException' if argument 'requiredType' is not specified.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @deprecated Since JavaScript ECMAScript 2015
        *
        * @param {any} thisContext
        * @param {any} requiredType
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidOperationException}
        */
        function checkConstructorCall(thisContext: any, requiredType: any): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the type of the argument 'parameter' evaluates to 'function' and checks whether the function
        *  returns an object if it is called with the 'new' operator and an empty argument list.
        *
        *  The function throws a 'TS.InvalidTypeException' if the call with the 'new' operator fails for any reason or the
        *  returned value is not an object, an empty object, null or undefined.
        *
        *  Attention, even if the check succeeded, the function specified in the argument 'parameter' may not be supposed
        *  to be called as a constructor function. (To be called with the new operator.) Since JavaScript allows to call
        *  every function with the new operator there is no way to tell whether a function was supposed to be used as a
        *  constructor function or not. But at least that check can tell that a call to that function as constructor
        *  function won't fail and will return an object of any type when the function passed the check.
        *
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkConstructorParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is a Date. Throws as 'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkDateParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is a valid date string. Throws as 'TS.InvalidTypeException' if
        *  not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkDateStringParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is a function. Throws as 'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkFunctionParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is an integer number in the range of
        *  [Number.MIN_SAFE_INTEGER...Number.MAX_SAFE_INTEGER]. Throws a 'TS.InvalidTypeException' if the value is
        *  either not an integer, out of range or not a number at all.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {number} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkIntNumberParameter(parameterName: string, parameter: number, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'type' is a valid type. Throws a 'TS.InvalidInvocationException' if not.
        *  Checks whether the value of argument 'parameter' is an instance of the type provide in argument 'type'.
        *  Throws a 'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {any} type
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidInvocationException}
        * @throws {TS.InvalidTypeException}
        */
        function checkInstanceOfParameter(parameterName: string, parameter: any, type: Object, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is iterable. Throws a 'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkIterableParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is an array of unsigned byte values. Throws a
        *  'TS.InvalidTypeException' if not. Checks whether the value of argument 'parameter' is an array with 16, 24 or
        *  32 elements. Throws a 'TS.ArgumentOutOfRangeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        * @throws {TS.ArgumentOutOfRangeException}
        */
        function checkKeyByteArray(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description This function checks the argument 'parameter' against null, undefined, an empty string and an empty
        *  array and throws a 'TS.ArgumentNullUndefOrEmptyException' if the argument is either of this.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullUndefOrEmptyException}
        */
        function checkNotEmptyParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against undefined and throws a
        *  'TS.ArgumentUndefinedException' if the argument is undefined.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentUndefinedException}
        */
        function checkNotUndefinedParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is a number. Throws a 'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkNumberParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is an object. Throws a 'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkObjectParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        */
        function checkParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the argument 'parameter' is a valid string. Throws a 'TS.InvalidTypeException' if not.
        *  Checks whether the argument 'parameter' is an empty string or whitespace only.Throws a
        *  'TS.ArgumentNullUndefOrWhiteSpaceException' if so.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.ArgumentNullUndefOrWhiteSpaceException}
        * @throws {TS.InvalidTypeException}
        */
        function checkStringParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is a valid array of unsigned bytes and throws a
        *  'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkUByteArrayParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is a valid unsigned byte value and throws a
        *  'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkUByteParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is an integer number in the range [0..Number.MAX_SAFE_INTEGER].
        *  Throws a 'TS.InvalidTypeException' if the value is either not an integer, out of range or not  a number at all.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkUIntNumberParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Checks the value of argument 'parameter' against null and undefined and throws a
        *  'TS.ArgumentNullOrUndefinedException' if the argument is either null or undefined.
        *  Checks whether the value of argument 'parameter' is a TS.TypeCode.UInt64 number. Throws a
        *  'TS.InvalidTypeException' if not.
        *  The exception messages use the 'parameterName' and 'functionName' in its message to signal which parameter
        *  failed the check and which function received the invalid parameter.
        *
        * @param {string} parameterName
        * @param {any} parameter
        * @param {string} functionName
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function checkUInt64NumberParameter(parameterName: string, parameter: any, functionName: string): void;
        /**
        * @description Takes a sparse array and returns a new created dense array. That is an array where all elements with
        *  an 'undefined' value are removed. If 'allowNull' is set to false, the elements with a 'null' value gets also
        *  removed. That is also the default behavior. Returns an empty array if it is called with an invalid argument.
        *
        * @param {Array<any>}, sparseArray
        * @param {boolean} allowNull,  Default = false
        *
        * @returns {Array<any>}
        */
        function compactArray(sparseArray: Array<any>, allowNull?: boolean): Array<any>;
        /**
        * @description Creates a version 4 random GUID which is returned as string in a canonical representation.
        *
        * @see {@link http://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29 | Wikipedia }
        * @see {@link http://www.ietf.org/rfc/rfc4122.txt | IETF }
        *
        * @returns {string}, The new created GUID as string.
        */
        function createGUID(): string;
        /**
        * @description Finds all currency elements which matches with the search pattern given in argument 'currency' and
        *  returns them in an array. The function returns an empty result array if there is no match for the provided
        *  search pattern.
        *
        * @param {string} currency, the search pattern used to identify a currency.
        *
        * @returns {Array<ICurrency>}, all matching currencies.
        */
        function findAllCurrencies(currency: string): Array<ICurrency>;
        /**
        * @description Finds the currency element which matches with the search pattern given in argument 'currency' and
        *  returns that currency element. If the search pattern leads to multiple results, a 'TS.AmbiguousResultException'
        *  exceptions gets thrown. The function returns null if there is no match for the provided search pattern.
        *
        * @param {string} currency, the search pattern used to identify a currency.
        *
        * @returns {ICurrency} | null, the identified currency, or null.
        *
        * @throws {TS.AmbiguousResultException}
        */
        function findSingleCurrency(currency: string): ICurrency | null;
        /**
         * @desciption Returns the corresponding value to a given key from the specified enumeration. If the key of enumObj
         *  is invalid, the returned value will be undefined. If the key is a string and the enumeration has a name value
         *  with a matching name, that value will be returned. If the key is a number and the enumeration has a named value
         *  with a matching value, the name of that value will be returned. This function does not implicitly convert
         *  number strings to numbers. That differs from the normal enum behavior and is by design. See example
         *
         * @example
         *
         *  enum testEnum = { ZERO, ONE, TWO };
         *
         *  testEnum[2];     // "TWO"
         *
         *  testEnum["ONE"]; // 1
         *
         *  testEnum["2"];   // "TWO"
         *
         *  getValueFromEnum[2];     // "TWO"
         *
         *  getValueFromEnum["ONE"]; // 1
         *
         *  getValueFromEnum["2"];   // undefined
         *
         * @param {string | number} key
         * @param {any} enumObj
         *
         * @returns {string | number | undefined}
         */
        function getValueFromEnum(key: string | number, enumObj: any): any;
        /**
        * @description Returns an array of unsigned 8 bit values which represent the hexadecimal string provided in
        *  argument 'hexString'. The function operates on character pairs to calculate the result values. That means
        *  the 'hexString' must only contain the hexadecimal representation of values which are expanded to character
        *  pairs if necessary. In other words, values below decimal 16 or hexadecimal 10 must be expanded with a
        *  leading zero. Without that rule you wouldn't be able to tell whether a string like: 'a105f' represents 5 values
        *  below 16, where each character represents one value, or lets say two values greater 16 and one below like in
        *  this example 'a1', '0', '5f'.
        *
        * @param {string} hexString
        *
        * @returns {Array<number>}
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.ArgumentNullUndefOrWhiteSpaceException}
        * @throws {TS.InvalidTypeException}
        * @throws {TS.InvalidFormatException}
         */
        function HexStringToUByteArray(hexString: string): Array<number>;
        /**
        * @description Searches for the next occurrence of 'searchString' in 'sourceString' beginning at position
        *  'startIndex' and returns the position in the string as number. If argument 'startIndex' isn't provided, search
        *  begins at the last position in 'sourceString'. The search direction is in reverse order. That means the search
        *  starts at the provided startIndes and goes down two lower indexes during search. Returns -1 if the
        *  'searchString' doesn't exist in the 'sourceString'.
        *
        * @param {string} sourceString
        * @param {number} startIndex,
        * @param {string} searchString
        *
        * @returns {number}, The position where the searchString was found or -1.
        */
        function nextIndexOfReverse(sourceString: string, searchString: string, startIndex?: number): number;
        /**
        * @description Returns the text representation of the given HTML DOM node type value. Returns the string 'undefined'
        *  if the value of argument 'nodeType' is invalid or unknown.
        *
        * @see {@link https://developer.mozilla.org/en/docs/Web/API/Node/nodeType | MSDN }
        *
        * @param {number} nodeType
        *
        * @returns {string}
        */
        function nodeTypeToString(nodeType: number): string;
        /**
        * @description Takes the string from argument 'path' and returns a new string which is normalized by the following
        *  rules:
        *
        * 1)  Replace all "\" by "/"
        *
        * 2)  Replace all "/./ by "/"
        *
        * 3)  Replace all "//" by "/";
        *
        * 4)  Navigate up one hierarchy level for all '/../' except for those at the root level.
        *
        * 5)  Remove trailing "/";
        *
        * @param {string} path
        *
        * @returns {string}
        */
        function normalizePath(path: string): string;
        /**
        * @description Returns a string which is padded with leading characters as specified in argument 'fillChar' until
        *  the length provided in argument 'length' is reached. The function returns a copy of the source string if the
        *  values of the arguments 'fillChar' or 'length' are invalid. A copy of the 'source' string is also returned if
        *  the length of the source is greater or equal the value of the 'length' parameter. The function doesn't truncate
        *  the string. The function returns a string consisting of a concatenation of 'fillChar' up to the length given in
        *  argument 'length' if the argument value of argument 'source' is invalid, null or empty.
        *
        * @param {string} source
        * @param {string} fillChar
        * @param {number} length
        *
        * @returns {string}
        */
        function padLeft(source: string, fillChar: string, length: number): string;
        /**
        * @description Removes the BOM from an UTF-8 encoded file.
        *
        * @param {string} text
        *
        * @returns {string}
        */
        function removeUTF8BOM(text: string): string;
        /**
        * @description Returns a string representation in hexadecimal notation of the unsigned 8 bit value provided in
        *  argument 'value'. The returned string has a fixed length of 2 characters. Number values below 16 are padded with
        *  a leading '0' character.
        *
        * @param {number}, value
        *
        * @returns {string}, A 2 characters string representing the UByte value.
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function UByteToHexString(value: number): string;
        /**
        * @description Changes the byte order in an unsigned 32 bit integer from [MostSignificant -> LeastSignificant] to
        *  [LeastSignifican -> MostSignificant] or vice versa. Returns the modified value afterwards.
        *
        * @param {number} value
        *
        * @returns {Array<number>}, The modified value
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        * @throws {TS.ArgumentOutOfRangeException}
        */
        function UInt32SwapSignificantByteOrder(value: number): number;
        /**
        * @description Converts the unsigned 32 bit integer number in argument 'value' into an array of 4 byte values and
        *  returns that array. The array will be padded with leading 0 byte values for lower numbers until the length of 4
        *  byte values is reached.
        *
        * @param {number} value
        *
        * @returns {Array<number>}, An array of 4 byte values.
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        * @throws {TS.ArgumentOutOfRangeException}
        */
        function UInt32To4ByteArray(value: number): Array<number>;
        /**
        * @description Returns a string representation in hexadecimal notation of the unsigned 32 bit integer value
        *  provided in argument 'value'. The returned string has a fixed length of 8 characters. The returned string will
        *  be padded with as much leading '0' as necessary to reach the length of 8 characters.
        *
        * @param {number}, value
        *
        * @returns {string}, A string of 8 characters representing the UInt32 value.
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        * @throws {TS.ArgumentOutOfRangeException}
        */
        function UInt32ToHexString(value: number): string;
        /**
        * @description Converts the unsigned integer number in argument 'value' into an array of byte values and returns
        *  that array. The array has as much elements as necessary to represent the value given in argument 'value'.
        *
        * @param {number} value, Has to be an unsigned integer.
        *
        * @returns {Array<number>}, An array of byte values.
        *
        * @throws {TS.ArgumentNullOrUndefinedException}
        * @throws {TS.InvalidTypeException}
        */
        function UIntToByteArray(value: number): Array<number>;
    }
    namespace Utils {
        /**
        * @description A collection of assertion functions. Those are functions which take on argument and return a
        *  boolean value. The boolean value describes whether the argument satisfies a specific condition or not.
        */
        namespace Assert {
            /**
            * @description Returns true if the type of the argument 'source' is an arguments type, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isArguments(source: any): boolean;
            /**
            * @description  Returns true if the type of the argument 'source' is an array type, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isArray(source: any): boolean;
            /**
            * @description  Returns true if the type of the argument 'source' is an array like type, otherwise false. Array
            *  like types are collections like the arguments collection or DOM collections. They have a length property but
            *  they are actually not arrays because they have no indexer.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isArrayLike(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a none empty binary string. If the string
            *  contains other characters than '0' and '1', even white space, the return value will be false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isBinaryString(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a boolean type, otherwise false.
            *
            * @see TS.Utils.Assert.isBooleanValue
            * @see TS.Utils.Assert.isBooleanObject
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isBoolean(source: any): boolean;
            /**
            * @description  Returns true if the type of the argument 'source' is a boolean object type created with
            *  'new Boolean()', otherwise false.
            *
            * @see TS.Utils.Assert.isBooleanValue
            * @see TS.Utils.Assert.isBoolean
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isBooleanObject(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a boolean value type (true or false),
            *  otherwise false.
            *
            * @see TS.Utils.Assert.isBoolean
            * @see TS.Utils.Assert.isBooleanObject
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isBooleanValue(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is an array of byte values, otherwise false.
            *  Byte values are values in the range of [-127..127].
            *
            * @see TS.Utils.Assert.isByteValue
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isByteArray(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is in the  range of signed byte values
            *  [-127 .. 127], otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isByteValue(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is considered a valid constructor function which
            *  creates a none empty object, otherwise false.
            *  An empty object is one which can be created using an object literal like '{}' or calling the Object
            *  constructor with a null argument 'new Object(null)'. If the constructor function returns such an object the
            *  constructor will fail the test.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isConstructor(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a date object type created with 'new Date()',
            *  otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isDate(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a valid date string otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isDateString(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a none empty decimal string. If the string
            *  contains other characters than [0-9], even white space, the return value will be false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isDecimalString(source: any): boolean;
            /**
            * @description  Returns true if the type of the argument 'source' is a dense array type. That means the array
            *  contains no element which is undefined. Returns false otherwise.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isDenseArray(source: any): boolean;
            /**
            * @description Returns true if the value of the argument 'source' is an empty array, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isEmptyArray(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is an enum type, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isEnum(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a function type, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isFunction(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a generator object type, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isGenerator(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a none empty hexadecimal string. If the
            *  string contains other characters than [0-9, A-F, a-f], even white space, the return value will be false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isHexString(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is an infinite number value type, otherwise
            *  false.
            *
            * @see TS.Utils.Assert.isNumber
            * @see TS.Utils.Assert.isNumberValue
            * @see TS.Utils.Assert.isNumberObject
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isInfiniteNumber(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is an instance of the type given in argument
            *  'type', otherwise false. That function doesn't do much more than calling the JavaScript 'instanceof'
            *  operator. The function is only created for your convenience. This way all assertion functions are in one
            *  place.
            *
            * @param {any} source
            * @param {any} type
            *
            * @returns {boolean}
            */
            function isInstanceOf(source: any, type: any): boolean;
            /**
            * @description Returns true if the value of the argument 'source' is an integer number in the range of
            *  [Number.MIN_SAFE_INTEGER..Number.MAX_SAFE_INTEGER], otherwise false.
            *
            * @see TS.Utils.Assert.isNumber
            * @see TS.Utils.Assert.isUnsignedIntegerNumber
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isIntegerNumber(source: any): boolean;
            /**
            * @description Returns true if the value of the argument 'source' is an iterable value, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isIterable(source: any): boolean;
            /**
            * @description This function is just a wrapper around the 'Number.isNaN' function. It's only purpose is to make
            *  the assertion functions available in on place.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isNaN(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a negative infinite number value type,
            *  otherwise false.
            *
            * @see TS.Utils.Assert.isNumber
            * @see TS.Utils.Assert.isNumberValue
            * @see TS.Utils.Assert.isNumberObject
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isNegativInfiniteNumber(source: any): boolean;
            /**
            * @description Returns true if the value of the argument 'source' is null, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isNull(source: any): boolean;
            /**
            * @description Returns true if the value of the argument 'source' is null or undefined, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isNullOrUndefined(source: any): boolean;
            /**
            * @description Returns true if the value of the argument 'source' is either null or undefined or an empty string
            *  or array. The function returns false for all argument values which are neither null or undefined nor an empty
            *  array or empty string.
            *
            * @param {Array<any> | string} source
            *
            * @returns {boolean}
            */
            function isNullUndefOrEmpty(source: Array<any>): boolean;
            function isNullUndefOrEmpty(source: string): boolean;
            /**
            * @description Returns true if the argument value is either null or undefined or is a string which is either empty
            *  or contains only white space characters.
            *
            * @param {string} source
            *
            * @returns {boolean}
            */
            function isNullUndefOrWhiteSpace(source: string): boolean;
            /**
            * @description  Returns true if the type of the argument 'source' is a number type, otherwise false.
            *
            * @see TS.Utils.Assert.isIntegerNumber
            * @see TS.Utils.Assert.isNumberObject
            * @see TS.Utils.Assert.isNumberValue
            * @see TS.Utils.Assert.isUnsignedIntegerNumber
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isNumber(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a number object type created with
            *  'new Number()', otherwise false.
            *
            * @see TS.Utils.Assert.isNumber
            * @see TS.Utils.Assert.isNumberValue
            *
            * @param {any} source
            * @returns {boolean}
            */
            function isNumberObject(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a number value type, otherwise false.
            *
            * @see TS.Utils.Assert.isNumber
            * @see TS.Utils.Assert.isNumberObject
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isNumberValue(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is an object type, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isObject(source: any): boolean;
            /**
            * @description Returns true if the type of argument 'source' is a plain object otherwise false. A plain object is
            *  an object without a prototype. It is either a literal object or an object created with 'Object.create'
            *  function called with a null argument.
            *
            * @example
            *
            * function Foo() {
            *   this.a = 1;
            * }
            *
            * isPlainObject(new Foo()) => false
            *
            * isPlainObject([1, 2, 3]) => false
            *
            * isPlainObject({ 'x': 0, 'y': 0 }) => true
            *
            * isPlainObject(Object.create(null)) => true
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isPlainObject(source: any): boolean;
            /**
            * @description Returns true if the type of argument 'source' is a primitive type. A primitive type is a type
            *  which is boolean | null | undefined | number | string | symbol. Every other type is considered a complex
            *  type.
            *
            * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures | JavaScript data types and data structures}
            *
            * @example
            *
            * isPrimitiveType(true) => true
            *
            * isPrimitiveType(null) => true
            *
            * isPrimitiveType(undefined) => true
            *
            * isPrimitiveType(12) => true
            *
            * isPrimitiveType(1.2) => true
            *
            * isPrimitiveType("One") => true
            *
            * isPrimitiveType([1, 2, 3]) => false
            *
            * isPrimitiveType({}) => false
            *
            * isPrimitiveType(new Boolean(false)) => false
            *
            * isPrimitiveType(new Number(13)) => false
            *
            * isPrimitiveType(new String("two")) => false
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isPrimitiveType(source: any): boolean;
            /**
            * @description  Returns true if the type of the argument 'source' is a regular expression type, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isRegEx(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a string type, otherwise false.
            *
            * @see TS.Utils.Assert.isStringLiteral
            * @see TS.Utils.Assert.isStringObject
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isString(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is an array of string values, otherwise false.
            *
            * @see TS.Utils.Assert.isStringValue
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isStringArray(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a string object type created with
            *  'new String()', otherwise false.
            *
            * @see TS.Utils.Assert.isString
            * @see TS.Utils.Assert.isStringLiteral
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isStringObject(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a string value type, otherwise false.
            *
            * @see TS.Utils.Assert.isString
            * @see TS.Utils.Assert.isStringObject
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isStringValue(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a symbol type, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isSymbol(source: any): boolean;
            /**
            * @description Returns true if the value of the argument 'source' is an UInt64Number, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isUInt64Number(source: any): boolean;
            /**
            * @description Returns true if the value of the argument 'source' is undefined, otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isUndefined(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is an array of unsigned byte values, otherwise
            *  false. Unsigned byte values are values in the range of [0..255]
            *
            * @see TS.Utils.Assert.isUnsignedByteValue
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isUnsignedByteArray(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is in the range of unsigned byte values
            *  [0 .. 255], otherwise false.
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isUnsignedByteValue(source: any): boolean;
            /**
            * @description Returns true if the type of the argument 'source' is a positive infinite number value type,
            *  otherwise false.
            *
            * @see TS.Utils.Assert.isNumber
            * @see TS.Utils.Assert.isNumberValue
            * @see TS.Utils.Assert.isNumberObject
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isUnsignedInfiniteNumber(source: any): boolean;
            /**
            * @description Returns true if the value of the argument 'source' is a valid integer number in the range of
            *  [0..Number.MAX_SAFE_INTEGER], otherwise false.
            *
            * @see TS.Utils.Assert.isNumber
            * @see TS.Utils.Assert.isIntegerNumber
            *
            * @param {any} source
            *
            * @returns {boolean}
            */
            function isUnsignedIntegerNumber(source: any): boolean;
            /**
            * @description Returns true if the value of the argument 'source' is a valid element of the enumeration in
            *  argument 'enumObj'. This function does not implicitly convert number strings to numbers. That differs from the
            *  normal enum behavior and is by design. See example.
            *
            * @example
            *
            *  enum testEnum = { ZERO, ONE, TWO };
            *
            *  testEnum[2];     // "TWO"  -> 2 accepted as valid enum member
            *
            *  testEnum["ONE"]; // 1      -> "ONE" accepted as valid enum member
            *
            *  testEnum["2"];   // "TWO"  -> "2" accepted as valid enum member
            *
            *  isValueOfEnum[2];     // true   -> 2 accepted as valid enum member
            *
            *  isValueOfEnum["ONE"]; // true   -> "ONE" accepted as valid enum member
            *
            *  isValueOfEnum["2"];   // false  -> "2" NOT accepted as valid enum member
            *
            * @param {number | string} source
            * @param {Object} enumObj
            *
            * @returns {boolean}
            */
            function isValueOfEnum(source: number | string, enumObj: any): boolean;
        }
    }
    namespace TypeCode {
        /**
        * @class TS.TypeCode.UInt64
        *
        * @descripion This class implements a 64 bit unsigned integer number type and some basic operations on this type.
        *  The UInt64 is used in some cipher algorithms.
        */
        class UInt64 {
            private internalMostSignificantInteger;
            private internalLeastSignificantInteger;
            /**
            * @description Returns the greatest number which can be stored in a UInt64.
            *
            * @get {TS.TypeCode.UInt64}  MAX_VALUE
            */
            static readonly MAX_VALUE: UInt64;
            /**
            * @description Returns the value of the most significant integer of this UInt64 number.
            *
            * @get {number} mostSignificantInteger
            */
            /**
            * @description Sets the value of the most significant integer of this UInt64 number.
            *
            * @set {number} mostSignificantInteger
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            * @throws TS.ArgumentOutOfRangeException
            */
            mostSignificantInteger: number;
            /**
            * @description Returns the value of the least significant integer of this UInt64 number.
            *
            * @get {number} leastSignificantInteger
            */
            /**
            * @description Sets the value of the least significant integer of this UInt64 number.
            *
            * @set {number} leastSignificantInteger
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            * @throws TS.ArgumentOutOfRangeException
            */
            leastSignificantInteger: number;
            /**
            * @constructor
            *
            * @description Creates a new UInt64 number
            *
            * @param {number} mostSignificantIntege
            * @param {number} leastSignificantInteger
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            * @throws TS.ArgumentOutOfRangeException
            */
            constructor(mostSignificantInteger?: number, leastSignificantInteger?: number);
            /**
            * @descriptions Adds a UInt64 value to the current value.
            *
            * @param {TS.TypeCode.UInt64} value
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            * @throws TS.OverflowException
            */
            add(value: TS.TypeCode.UInt64): void;
            /**
            * @descriptions Adds two UInt64 numbers and returns the result.
            *
            * @param {TS.TypeCode.UInt64} first
            * @param {TS.TypeCode.UInt64} second
            *
            * @returns {TS.TypeCode.UInt64}
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            * @throws TS.OverflowException
            */
            static add(first: TS.TypeCode.UInt64, second: TS.TypeCode.UInt64): TS.TypeCode.UInt64;
            /**
            * @description Adds a UInt64 value to the current value in modulo operation mode.
            *
            * @param {TS.TypeCode.UInt64} value
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            */
            addModulo(value: TS.TypeCode.UInt64): void;
            /**
            * @description Adds two UInt64 values in modulo operation mode and returns the result.
            *
            * @param {TS.TypeCode.UInt64} first
            * @param {TS.TypeCode.UInt64} second
            *
            * @returns {TS.TypeCode.UInt64}
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            */
            static addModulo(first: TS.TypeCode.UInt64, second: TS.TypeCode.UInt64): TS.TypeCode.UInt64;
            /**
            * @description Compares the current value with the value given in argument 'other' and returns true if the
            *  'other' value is equal to the current value, otherwise false.
            *
            * @param {TS.TypeCode.UInt64} value
            *
            * @returns {boolean}
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            */
            equal(other: TS.TypeCode.UInt64): boolean;
            /**
            * @description Compares two UInt64 values and returns true if both values are equal, otherwise false.
            *
            * @param {TS.TypeCode.UInt64} first
            * @param {TS.TypeCode.UInt64} second
            *
            * @returns {boolean}
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            */
            static equal(first: TS.TypeCode.UInt64, second: TS.TypeCode.UInt64): boolean;
            /**
            * @description Compares the current value with the value given in argument 'other' and returns true if the
            *  current value is grater than the 'other' value, otherwise false.
            *
            * @param {TS.TypeCode.UInt64} value
            *
            * @returns {boolean}
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            */
            greater(other: TS.TypeCode.UInt64): boolean;
            /**
            * @description Compares two UInt64 values and returns true if the first value is grater than the second value,
            *  otherwise false.
            *
            * @param {TS.TypeCode.UInt64} first
            * @param {TS.TypeCode.UInt64} second
            *
            * @returns {boolean}
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            */
            static greater(first: TS.TypeCode.UInt64, second: TS.TypeCode.UInt64): boolean;
            /**
            * @description Compares the current value with the value given in argument 'other' and returns true if the
            *  current value is less than the 'other' value, otherwise false.
            *
            * @param {TS.TypeCode.UInt64} value
            *
            * @returns {boolean}
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            */
            less(other: TS.TypeCode.UInt64): boolean;
            /**
            * @description Compares two UInt64 values and returns true if the first value is less than the second value,
            *  otherwise false.
            *
            * @param {TS.TypeCode.UInt64} first
            * @param {TS.TypeCode.UInt64} second
            *
            * @returns {boolean}
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.InvalidTypeException
            */
            static less(first: TS.TypeCode.UInt64, second: TS.TypeCode.UInt64): boolean;
            /**
            * @description Casts an unsigned integer number into an UInt64.
            *
            * @param {number} intNumber
            *
            * @returns {TS.TypeCode.UInt64}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            static UIntToUInt64(intNumber: number): TS.TypeCode.UInt64;
            /**
            * @description Casts an UInt64 number into an integer. Throws an overflow exceptions if the UInt64 number exceeds
            *  the range of 'Number.MAX_SAVE_INTEGER'.
            *
            * @param {TS.TypeCode.UInt64} UInt64Number
            *
            * @returns {number}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.OverflowException}
            */
            static UInt64ToUInt(UInt64Number: TS.TypeCode.UInt64): number;
        }
    }
    namespace Encoding {
        /**
        * @class TS.Encoding.Base64
        *
        * @description This class implements a base64 encoding and decoding function.
        *
        * @see {@link https://www.ietf.org/rfc/rfc3548.txt | IETF}
        */
        class Base64 {
            private static BASE64_CHARACTER_SET;
            /**
            * @description  Decodes a base64 encoded UTF-8 string and returns the decoded UTF-16 string. The decode function
            *  is functional equivalent to the following C# code:
            *
            * @example
            *  var byteArray = System.Convert.FromBase64String(data));
            *
            *  var resultString = System.Text.Encoding.UTF8.GetString(byteArray);
            *
            * @static
            *
            * @param {string} data, The base64 encoded data as string.
            *
            * @returns {string}, The decoded plain text as string.
            *
            * @throws {TS.ArgumentNullUndefOrEmptyException}
            * @throws {TS.ArgumentNullUndefOrWhiteSpaceException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidFormatException}
            */
            static decode(data: string): string;
            /**
            * @description  Decodes a base64 encoded string and returns the decoded string as byte array. The
            *  decodeToByteArray function is functional equivalent to the following C# code:
            *
            * @example
            *  var byteArray = System.Convert.FromBase64String(data));
            *
            * @static
            *
            * @param {string} data, The base64 encoded data as string.
            *
            * @returns {Array<number>}, The decoded data as byte array.
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.ArgumentNullUndefOrWhiteSpaceException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidFormatException}
            */
            static decodeToByteArray(data: string): Array<number>;
            /**
            * @description Encodes the given UTF-16 string to UTF-8 in a first step and then to base64 in a second step and
            *  returns that encoded string. The encode function is functional equivalent to the following C# code:
            *
            * @example
            *  var byteArray = System.Text.Encoding.UTF8.GetBytes(data);
            *
            *  var resultString = System.Convert.ToBase64String(byteArray);
            *
            * @static
            *
            * @param {string} data, The plain text to encode as string.
            *
            * @returns {string}, The base64 encoded data as string.
            *
            * @throws {TS.ArgumentNullUndefOrEmptyException}
            * @throws {TS.InvalidTypeException}
            */
            static encode(data: string): string;
            /**
            * @description Encodes the given UTF-16 string to UTF-8 in a first step then to base64 in a second step and makes
            *  the resulting string URL compliant in a last step and returns the resulting string. The result string can be
            *  used as query string data.
            *
            * @static
            *
            * @param {string} data, The plain text to encode as string.
            *
            * @returns {string}, The URL compliant base64 encoded data as string.
            *
            * @throws {TS.InvalidTypeException}
            */
            static encodeURLCompliant(data: string): string;
        }
    }
    namespace Encoding {
        /**
        * @class TS.Encoding.UTF
        *
        * @description This class implements UTF-16LE / UCS-2LE string conversion into a UTF-8 byte array and vice versa.
        */
        class UTF {
            /**
            * @description Takes an arbitrary UCS-2LE or UTF-16LE string and returns an array of UTF-8 encoded bytes which
            *  represent the input string in UTF-8 encoding. Since javascript strings are always UCS-2 or UTF-16 and DOM
            *  strings always UTF-16, this function is able to convert all strings which may occur in a javascript program,
            *  into an UTF-8 byte array.
            *
            * @static
            *
            * @param {string} input, The string which gets encoded to UTF8.
            *
            * @returns {Array<number>}, The resulting byte array.
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidOperationException}
            */
            static UTF16StringToUTF8Array(input: string): Array<number>;
            /**
            * @description Takes a byte array of UTF-8 encoded bytes and converts them into a javascript string which is at
            *  least an UCS-2 string, but more probably an UTF-16 string. It depends on your javascript engine.
            *
            * @static
            *
            * @param {Array<number>} byteArray, An UTF8 array which gets converted to an UTF16 string.
            *
            * @returns {string}, The resulting UTF16 string.
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidOperationException}
            */
            static UTF8ArrayToUTF16String(byteArray: Array<number>): string;
        }
    }
    namespace IO {
        enum StreamStateEnum {
            READY = 0,
            REQUEST_FOR_CLOSE = 1,
            CLOSED = 2,
            ERROR = 3,
        }
    }
    namespace IO {
        interface IStream<T> {
            /**
            * @description Synchronous write operation.
            */
            write: (data: T | Array<T>, timeout?: number) => void;
            /**
            * @description Asynchronous write operation.
            */
            writeAsync: (data: T | Array<T>, timeout?: number) => Promise<any>;
            /**
            * @description A function which closes the stream for further write operations.
            */
            close: () => void;
            /**
            * @description A reference to the callback function which gets called when the stream finally closed.
            */
            readonly onClosed: ((stream: TS.IO.IStream<T>) => void) | null;
            /**
            * @description A reference to the callback function which gets called when the stream has data to read.
            */
            readonly onData: ((stream: TS.IO.IStream<T>) => void) | null;
            /**
            * @description A reference to the callback function which gets called when the stream ran into an error.
            */
            readonly onError: ((stream: TS.IO.IStream<T>) => void) | null;
            /**
            * @description A flag which tells whether the stream is closed.
            */
            readonly isClosed: boolean;
            /**
            * @description A flag which tells whether the stream has data to read.
            */
            readonly hasData: boolean;
            /**
            * @description A flag which tells whether the stream is locked in an error state.
            */
            readonly hasError: boolean;
            /**
            * @description A flag which tells whether the stream is ready for write operations. If 'canWrite' is true, that
            *  doesn't necessarily mean that there is enough buffer space for your next write operation if you are in
            *  synchronous mode.
            *
            * @see freeBufferSize
            */
            readonly canWrite: boolean;
            /**
            * @description A flag which tells whether the stream is ready for read operations.
            */
            readonly canRead: boolean;
            /**
            * @descriptions This property tells you how much buffer size is currently available.
            */
            readonly freeBufferSize: number;
            /**
            * @description A property which reveals the stream state.
            */
            readonly state: TS.IO.StreamStateEnum;
            /**
            * @description A property which reveals the error which locked the stream.
            */
            readonly error: TS.Exception | null;
        }
    }
    namespace IO {
        /**
        * @class TS.IO.Stream
        *
        * @description This is a simple buffered stream implementation. The stream is a one time stream and unidirectional.
        *  One time stream means, you can't use that stream any longer after the stream has closed or ran into an error
        *  state. Unidirectional means you can transport elements form the sender to the receiver but not vice versa. The
        *  stream has two operation modes. The receiver can either poll for new data on the stream or opt for an event
        *  driven operation mode. If you opt for the event driven operation mode, you have to use the appropriate
        *  constructor which requires three callback handlers to control the data transmission. If you opt for polling use
        *  one of the other constructors. The stream is not a byte stream. That means simple types are transfered by value
        *  but reference types will be transfered as reference. The object on the receiver side is the same as the one on
        *  the sender side and not a deserialized clone of that object. Keep that in mind to avoid unexpected behavior.
        *
        * @implements {TS.IO.IStream<T>}
        */
        class Stream<T> implements TS.IO.IStream<T> {
            private internalDataAnnounceTimeout;
            private internalWriteLoopTimeout;
            private internalDataAnnounceHandler;
            private internalState;
            private internalBuffer;
            private internalMaxBufferSize;
            private internalError;
            private internalOnClosed;
            private internalOnError;
            private internalOnData;
            private internalOutstandingPromiseCounter;
            /**
            * @description Returns the current stream state.
            *
            * @implements {TS.IO.IStream}
            *
            * @get {TS.IO.StreamStateEnum}
            */
            readonly state: TS.IO.StreamStateEnum;
            /**
            * @description Returns the exception which locked the stream.
            *
            * @implements {TS.IO.IStream}
            *
            * @get { TS.Exception}
            */
            readonly error: TS.Exception | null;
            /**
            * @description Returns true if the stream is in an error state.
            *
            * @implements {TS.IO.IStream}
            *
            * @get {boolean}
            */
            readonly hasError: boolean;
            /**
            * @description Returns true if the stream buffer has data to read.
            *
            * @implements {TS.IO.IStream}
            *
            * @get {boolean}
            */
            readonly hasData: boolean;
            /**
            * @description Returns true if the stream is close.
            *
            * @implements {TS.IO.IStream}
            *
            * @get {boolean}
            */
            readonly isClosed: boolean;
            /**
            * @description Returns the 'onClosed' callback function which was set during construction or null.
            *
            * @implements {TS.IO.IStream}
            *
            * @get {((stream: TS.IO.IStream<T>) => void) | null}
            */
            readonly onClosed: ((stream: TS.IO.IStream<T>) => void) | null;
            /**
            * @description Returns the 'onData' callback function which was set during construction or null.
            *
            * @implements {TS.IO.IStream}
            *
            * @get {((stream: TS.IO.IStream<T>) => void) | null}
            */
            readonly onData: ((stream: TS.IO.IStream<T>) => void) | null;
            /**
            * @description Returns the 'onError' callback function which was set during construction or null.
            *
            * @implements {TS.IO.IStream}
            *
            * @get {((stream: TS.IO.IStream<T>) => void) | null}
            */
            readonly onError: ((stream: TS.IO.IStream<T>) => void) | null;
            /**
            * @description Returns true if the stream is ready for write operations.
            *
            * @implements {TS.IO.IStream}
            *
            * @get {boolean}
            */
            readonly canWrite: boolean;
            /**
            * @description Returns size of the buffer which is currently available.
            *
            * @implements {TS.IO.IStream}
            *
            * @get {number}
            */
            readonly freeBufferSize: number;
            /**
            * @description Returns true if the stream is ready for read operations.
            *
            * @implements {TS.IO.IStream}
            *
            * @get {boolean}
            */
            readonly canRead: boolean;
            /**
            * @constructor
            *
            * @description Creates a new stream with the maximum buffer size set to 'Number.MAX_SAFE_INTEGER'.
            */
            constructor();
            /**
            * @constructor
            *
            * @description Creates a new stream with the maximum buffer size set to value given in argument 'maxBufferSize'.
            *
            * @param {number} maxBufferSize, Must be a valid integer > 0.
            *
            * @throws {TS.InvalidTypeException}
            * @throws {TS.ArgumentOutOfRangeException}
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {InvalidInvocationException}
            */
            constructor(maxBufferSize: number);
            /**
            * @constructor
            *
            * @description Creates a new stream with the maximum buffer size set to value given in argument 'maxBufferSize'.
            *  Binds the callback functions to the corresponding events for transmission control on the receiver side.
            *
            * @param {number} maxBufferSize, Must be a valid integer > 0.
            * @param {(stream: TS.IO.IStream<T>) => void} onClosedCallback, Callback which gets called when the stream closed.
            * @param {(stream: TS.IO.IStream<T>) => void} onDataCallback, Callback which gets called when new data arrived.
            * @param {(stream: TS.IO.IStream<T>) => void} onErrorCallback, Callback which gets called when an error occurred.
            *
            * @throws {TS.InvalidTypeException}
            * @throws {TS.ArgumentOutOfRangeException}
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {InvalidInvocationException}
            */
            constructor(maxBufferSize: number, onClosedCallback: (stream: TS.IO.IStream<T>) => void, onDataCallback: (stream: TS.IO.IStream<T>) => void, onErrorCallback: (stream: TS.IO.IStream<T>) => void);
            /**
            * @description Tries to call the 'onData' callback handler.
            */
            private tryOnData();
            /**
            * @description Sets the stream state to 'TS.IO.StreamStateEnum.ERROR' and stores the error in the 'internalError'
            *  variable for later use.
            *
            * @private
            *
            * @param {TS.Exception} value
            */
            private setError(value);
            /**
            * @description Clears a previous created timeout timer.
            *
            * @private
            *
            * @param {number} timer
            */
            private clearTimeout(timer);
            /**
            * @description Sets a new timeout timer.
            *
            * @private
            *
            * @param {() => void} handler, The handler which gets called when the timeout is reached.
            * @param {number} timeout, The timespan in ms before the handler gets called.
            *
            * @returns {number}, The timeout timer handle.
            *
            * @throws {TS.EnvironmentNotSupportedException}
            */
            private setTimeout(handler, timeout);
            /**
            * @description Clears a previous created interval timer.
            *
            * @private
            *
            * @param {number} timer
            */
            private clearInterval(timer);
            /**
            * @description Sets a new interval timer.
            *
            * @private
            *
            * @param {() => void} handler, The handler which gets called when the timeout is reached.
            * @param {number} interval, The timespan in ms between to calls of the handler.
            *
            * @returns {number}, The interval timer handle.
            *
            * @throws {TS.EnvironmentNotSupportedException}
            */
            private setInterval(handler, interval);
            /**
            * @description Clears the internal buffer, removes all callback functions except for 'onClosed' and sets the
            *  'internalState' to 'TS.IO.StreamStateEnum.CLOSED' if the stream isn't already in an error state.
            *
            * @private
            */
            private internalClose();
            /**
            * @description Writes the data given in argument 'data' to the stream in a synchronous way. This function may call
            *  the stream 'onError' callback for a 'TS.BufferOverrunException' exceptions which may rise during the write
            *  operation.
            *
            * @implements {TS.IO.IStream}
            *
            * @param {T | Array<T>} data, A single value of type T or an arbitrary array of type T which is the payload to write.
            *
            * @throws {TS.ArgumentUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidOperationException}
            * @throws {TS.BufferOverrunException}
            */
            write(data: T | Array<T>): void;
            /**
            * @description The function returns a promise which will have written the data to the buffer, once it is resolved.
            *  The data may hold an array of type T or a single value of type T. The single value must not be undefined as
            *  well as the array of type T must be a dense array. (Must not contain undefined values)
            *  The asynchronous write operation does not guarantee that the data gets streamed in the same order it was
            *  supplied to the 'writeAsync' function. You need to synchronize your calls to the 'writeAsync' function
            *  yourself if the order of the data is important in any way. You may also use the synchronous 'write' function.
            *  This function may call the stream 'onError' callback for 'TS.InvalidOperationException' and
            *  'TS.TimeoutException' exceptions which may rise during the promise execution.
            *
            * @implements {TS.IO.IStream}
            *
            * @param {T | Array<T>} data, A single value of type T or an arbitrary array of type T which is the payload to write.
            * @param {number} timeout, Write operation timeout in seconds. Must be an unsigned integer > 0.
            *
            * @returns {Promise<any>}, Resolves with a void value and signals 'TS.InvalidOperationException' and
            *  'TS.TimeoutException' on the reject callback.
            *
            * @throws {TS.ArgumentUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidOperationException}
            */
            writeAsync(data: T | Array<T>, timeout?: number): Promise<any>;
            /**
            * @description Returns the next element from the stream or 'undefined' if no element is available. To prevent an
            *  'undefined' result check the 'hasData' property before reading.
            *
            * @returns {T | undefined}, The next element from the stream or undefined if there is no element available.
            *
            * @throws {TS.InvalidOperationException}
            */
            read(): T | undefined;
            /**
            * @description Returns all elements which are currently buffered in the stream as an array. That array may be
            *  empty if there isn't buffered data available. To prevent empty results check the 'hasData' property before
            *  reading.
            *
            * @returns {Array<T>}, The currently buffered data from the stream.
            *
            * @throws {TS.InvalidOperationException}
            */
            readBuffer(): Array<T>;
            /**
            * @description Places a request to close the stream. After a call to this function further write operation are
            *  allowed. A violation of that rule will leave the stream in an erroneous state.
            *
            * @implements {TS.IO.IStream}
            */
            close(): void;
        }
    }
    namespace Linq {
        /**
        * @class TS.Linq.SelectorException
        *
        * @description This exceptions signals an error which occurred in a selector function for specific value.
        *
        * @extends {TS.Exception}
        */
        class SelectorException extends TS.Exception {
            /**
            * @private
            */
            private internalSelector;
            /**
            * @private
            */
            private internalValue;
            /**
            * @override
            *
            * @get {string} type
            */
            readonly type: string;
            /**
            * @description The selector which caused the exception.
            *
            * @get {(item: any) => Enumerator<any>} selector
            */
            readonly selector: (item: any) => Enumerator<any>;
            /**
            * @description The value which caused the exception.
            *
            * @get {any} value
            */
            readonly value: any;
            /**
            * @constructor
            *
            * @param {(item: any) => Enumerator<any>} selector
            * @param {any} value
            * @param {string} message?
            * @param {TS.Exception} innerException)
            */
            constructor(selector: (item: any) => Enumerator<any>, value: any, message?: string, innerException?: TS.Exception);
            /**
            * @constructor
            *
            * @param { (item: any) => Array<any>} selector
            * @param {any} value
            * @param {string} message?
            * @param {TS.Exception} innerException)
            */
            constructor(selector: (item: any) => Array<any>, value: any, message?: string, innerException?: TS.Exception);
            /**
            * @constructor
            *
            * @param { (item: any) =>any} selector
            * @param {any} value
            * @param {string} message?
            * @param {TS.Exception} innerException)
            */
            constructor(selector: (item: any) => any, value: any, message?: string, innerException?: TS.Exception);
        }
        /**
        * @class TS.Linq.EmptyEnumeratorException
        *
        * @description This exceptions signals an error in a function which expects a none empty enumerator to operate on.
        *
        * @extends {TS.Exception}
        */
        class EmptyEnumeratorException extends TS.Exception {
            /**
            * @private
            */
            private internalEnumerator;
            /**
            * @override
            *
            * @get {string} type
            */
            readonly type: string;
            /**
            * @description The enumerator which caused the exception.
            *
            * @get {Iterable<any>} enumerator
            */
            readonly enumerator: Iterable<any>;
            /**
            * @constructor
            *
            * @param {Iterable<any>} enumerator
            * @param {string}  message?
            */
            constructor(enumerator: Iterable<any>, message?: string, innerException?: TS.Exception);
        }
        /**
        * @class TS.Linq.MoreThanOneElementException
        *
        * @description This exceptions signals an error in a function where only one element is allowed but multiple
        *  elements are available.
        *
        * @extends {TS.Exception}
        */
        class MoreThanOneElementException extends TS.Exception {
            /**
            * @private
            */
            private internalEnumerator;
            /**
            * @override
            *
            * @get {string} type
            */
            readonly type: string;
            /**
            * @description The enumerator which caused the exception.
            *
            * @get {Iterable<any>} enumerator
            */
            readonly enumerator: Iterable<any>;
            /**
            * @constructor
            *
            * @param {Iterable<any>} enumerator
            * @param {string} message?
            * @param {TS.Exception} innerException)
            */
            constructor(enumerator: Iterable<any>, message?: string, innerException?: TS.Exception);
        }
    }
    namespace Linq {
        /**
        * @class TS.Linq.BaseEnumerator<T>
        *
        * @description  The main purpose of this class is to implement the extension functions defined in
        *  'TS.Linq.Extensions' in order to make them available in subclasses.
        *
        * @abstract
        *
        * @implements {Iterable<T>}
        */
        abstract class BaseEnumerator<T> implements Iterable<T> {
            /**
            * @abstract
            *
            * @implements {Iterable<T>}
            */
            abstract [Symbol.iterator](): Iterator<T>;
            /**
            * @description Applies an accumulator function over a sequence.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb548651.aspx | MSDN}
            *
            * @param {(first: T, second: T) => T} accumulator
            *
            * @returns {T}
            *
            * @throws {TS.Linq.EmptyEnumeratorException}
            * @throws {TS.InvalidTypeException}
            */
            aggregate(accumulator: (first: T, second: T) => T): T;
            /**
            * @description Applies an accumulator function over a sequence. The specified seed value is used as the initial
            *  accumulator value.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb549218.aspx | MSDN}
            *
            * @param {(first: TAccumulate, second: T) => TAccumulate} accumulator
            * @param {TAccumulate} seed
            *
            * @returns {TAccumulate}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            aggregate<TAccumulate>(accumulator: (first: TAccumulate, second: T) => TAccumulate, seed: TAccumulate): TAccumulate;
            /**
            * @description Determines whether all elements of a sequence satisfy a condition.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb548541.aspx | MSDN}
            *
            * @param {(item: TSource) => boolean} predicate
            *
            * @returns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            all(predicate: (item: T) => boolean): boolean;
            /**
            * @description Determines whether a sequence contains any elements.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb337697.aspx | MSDN}
            *
            * @param {Iterable<T>} enumerator
            *
            * @returns {boolean}
            */
            any(): boolean;
            /**
            * @description Determines whether any element of a sequence satisfies a condition.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534972.aspx | MSDN}
            *
            * @param {(item: T) => boolean} predicate
            *
            * @returns {boolean}
            *
            * @throws {TS.InvalidTypeException}
            */
            any(predicate: (item: T) => boolean): boolean;
            /**
            * @description Computes the average of a sequence of number values.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb354760.aspx | MSDN}
            *
            * @returns {number}
            *
            * @throws {TS.InvalidOperationException}
            */
            average(): number;
            /**
            * @description Concatenates two sequences.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb302894.aspx | MSDN}
            *
            * @param {Iterable<TSource>} secondEnumerator
            *
            * @returns { TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}.
            */
            concat(secondEnumerator: Iterable<T>): TS.Linq.Enumerator<T>;
            /**
            * @description Determines whether a sequence contains a specified element by using the default equality comparer.
            *  Uses javascript strict comparison operator 'strict equality (===)' to determine whether an elements in the
            *  enumeration matches with the specified search element. This function may produce results that differ from the
            *  C# counterpart, because the comparison operators have different implementations in C# and javascript.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb352880.aspx | MSDN}
            *
            * @param {T} element
            *
            * @returns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            */
            contains(element: T): boolean;
            /**
            * @description Determines whether a sequence contains a specified element by using a specified equality comparer.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb339118.aspx | MSDN}
            *
            * @param {T} element
            * @param {(first: TSource, second: TSource) => boolean}  equalityComparer
            *
            * @returns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            contains(element: T, equalityComparer: (first: T, second: T) => boolean): boolean;
            /**
            * @description Returns the number of elements in a sequence.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.count.aspx | MSDN}
            *
            * @returns {number}
            */
            count(): number;
            /**
            * @description Returns a number that represents how many elements in the specified sequence satisfy a condition.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb535181.aspx | MSDN}
            *
            * @param {(item: T) => boolean} predicate
            *
            * @returns {number}
            *
            * @throws {TS.InvalidTypeException}
            */
            count(predicate: (item: T) => boolean): number;
            /**
            * @description This function returns an endless number of elements from the underlying sequence by running over
            *  that sequence in cycles. The function enumerates the elements of the base sequence from the start to then end
            *  and starts over with the first element as soon as the last element is reached. This function will never run
            *  out of data. There is one exception of that rule. If the underlying sequence is an empty sequence, the cycle
            *  function will never give a result.
            *
            *  Attention:
            *  Use this function with a subsequent call to 'take' to limit the output or you will run out of memory.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @returns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            cycle(): TS.Linq.Enumerator<T>;
            /**
            * @description Returns the elements of an enumerator, or a default valued singleton collection if the sequence is
            *  empty. That function differs from the .NET counterpart in that way that is has a 'defaultConstructorOrValue'
            *  in the signature. That argument is needed because javascript doesn't offer reflections or a type system which
            *  you can rely on at runtime. Hence there is no way to tell which constructor to use for the default when you
            *  are dealing with a complex type or which default value to use when you are dealing with a primitive type. The
            *  only way to make sure that you get the right type at runtime is to place the default constructor or value in
            *  the parameter list of that function.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.defaultifempty.aspx | MSDN}
            *
            * @param  { new (): T; } | T) defaultConstructorOrValue
            *
            * @retuns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            */
            defaultIfEmpty(defaultConstructorOrValue: {
                new (): T;
            } | T): TS.Linq.Enumerator<T>;
            /**
            * @description Returns distinct elements from a sequence by using the default equality comparer to compare values.
            *  Uses javascript strict comparison operator 'strict equality (===)' to achieve distinction.
            *  This function may produce results that differ from the C# counterpart, because the comparison operators have
            *  different implementations in C# and javascript.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.distinct.aspx | MSDN}
            *
            * @retuns {TS.Linq.Enumerator<T>}
            */
            distinct(): TS.Linq.Enumerator<T>;
            /**
            * @description Returns distinct elements from a sequence by using a specified equality comparer to compare values.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.distinct.aspx | MSDN}
            *
            * @param {(first: T, second: T) => boolean} equalityComparer
            *
            * @retuns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.InvalidTypeException}
            */
            distinct(equalityComparer: (first: T, second: T) => boolean): TS.Linq.Enumerator<T>;
            /**
            * @description Returns the element at a specified index in a sequence.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx | MSDN}
            *
            * @param {number} index
            *
            * @retuns {T}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.IndexOutOfRangeException}
            * @throws {TS.InvalidTypeException}
            */
            elementAt(index: number): T;
            /**
            * @description Returns the element at a specified index in a sequence or a default value
            *  if the index is out of the range of the sequence.
            *  That function differs from the .NET counterpart in that way that is has a 'defaultConstructorOrValue' in the
            *  signature. That argument is needed because javascript doesn't offer reflections or a type system which you
            *  can rely on at runtime. Hence there is no way to tell which constructor to use for the default when you are
            *  dealing with a complex type or which default value to use when you are dealing with a primitive type. The only
            *  way to make sure that you get the right type at runtime is to place the default constructor or value in the
            *  parameter list of that function.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb494386(v=vs.110).aspx | MSDN}
            *
            * @param {number} index
            * @param {{ new (): T; } | T} defaultConstructorOrValue
            *
            * @retuns {T}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            elementAtOrDefault(index: number, defaultConstructorOrValue: {
                new (): T;
            } | T): T;
            /**
            * @description Produces the set difference of two sequences.
            *  Uses javascript strict comparison operator 'strict equality (===)' to achieve distinction.
            *  This function may produce results that differ from the C# counterpart, because the comparison operators have
            *  different implementations in C# and javascript.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb300779.aspx | MSDN}
            *
            * @param {Iterable<T>} secondEnumerator
            *
            * @retuns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            except(secondEnumerator: Iterable<T>): TS.Linq.Enumerator<T>;
            /**
            * @description Produces the set difference of two sequences by using the specified equality comparer to compare
            *  values.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb336390.aspx | MSDN}
            *
            * @param {Iterable<T>} secondEnumerator
            * @param {(first: T, second: T) => boolean)} equalityComparer
            *
            * @retuns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            except(secondEnumerator: Iterable<T>, equalityComparer: (first: T, second: T) => boolean): TS.Linq.Enumerator<T>;
            /**
            * @description Returns the first element of a sequence.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.first.aspx | MSDN}
            *
            * @returns {T}
            *
            * @throws {TS.InvalidOperationException}
            */
            first(): T;
            /**
            * @description Returns the first element in a sequence that satisfies a specified condition.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.first.aspx | MSDN}
            *
            * @param {(item: T) => boolean} predicate
            *
            * @returns {T}
            *
            * @throws {TS.InvalidOperationException}
            * @throws {TS.InvalidTypeException}
            */
            first(predicate: (item: T) => boolean): T;
            /**
            * @description Returns the first element of a sequence, or a default value if the sequence contains no elements.
            *  That function differs from the .NET counterpart in that way that is has a 'defaultConstructorOrValue' in the
            *  signature. That argument is needed because javascript doesn't offer reflections or a type system which you
            *  can rely on at runtime. Hence there is no way to tell which constructor to use for the default when you are
            *  dealing with a complex type or which default value to use when you are dealing with a primitive type. The only
            *  way to make sure that you get the right type at runtime is to place the default constructor or value in the
            *  parameter list of that function.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.firstordefault.aspx | MSDN}
            *
            * @param {{ new (): T; } | T} defaultConstructorOrValue
            *
            * @returns {T}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            firstOrDefault(defaultConstructorOrValue: {
                new (): T;
            } | T): T;
            /**
            * @description Returns the first element of the sequence that satisfies a condition or a default value if no
            *  element satisfied the condition. That function differs from the .NET counterpart in that way that is has a
            *  'defaultConstructorOrValue' in the signature. That argument is needed because javascript doesn't offer
            *  reflection or a type system which you can rely on at runtime. Hence there is no way to tell which constructor
            *  to use for the default when you are dealing with a complex type or which default value to use when you are
            *  dealing with a primitive type. The only way to make sure that you get the right type at runtime is to place
            *  the default constructor or value in the parameter list of that function.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.firstordefault.aspx | MSDN}
            *
            * @param {{ new (): T; } | T} defaultConstructorOrValue
            * @param {(item: TSource) => boolean} predicate
            *
            * @returns {T}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            firstOrDefault(defaultConstructorOrValue: {
                new (): T;
            } | T, predicate: (item: T) => boolean): T;
            /**
            * @description Performs the specified action on each element of the underlying sequence. This function is not a
            *  Linq function. I implemented this extension for your convenience. Without that function you had to call
            *  'toArray' first before you could use the array method for each. Please read the article below from
            *  'Eric Lippert's' blog to make sure that you understand all the implications of this extension function.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link http://blogs.msdn.com/b/ericlippert/archive/2009/05/18/foreach-vs-foreach.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => void } action
            *
            * @retuns {Iterable<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            forEach(action: (item: T) => void): TS.Linq.Enumerator<T>;
            /**
            * @description Groups the elements of a sequence according to a specified key selector function.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.groupby.aspx | MSDN}
            *
            * @param {(item: T) => TKey} keySelector
            *
            * @returns {TS.Linq.Enumerator<Grouping<TKey, T>>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            groupBy<TKey>(keySelector: (item: T) => TKey): TS.Linq.Enumerator<TS.Linq.Grouping<TKey, T>>;
            /**
            * @description Groups the elements of a sequence according to a specified key selector function.
            *  The keys are compared by using the specified comparer in argument 'equalityComparer'.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.groupby.aspx | MSDN}
            *
            * @param {(item: T) => TKey} keySelector
            * @param {(first: TKey, second: TKey) => boolean} equalityComparer
            *
            * @returns {TS.Linq.Enumerator<TS.Linq.Grouping<TKey, T>>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            groupBy<TKey>(keySelector: (item: T) => TKey, equalityComparer: (first: TKey, second: TKey) => boolean): TS.Linq.Enumerator<TS.Linq.Grouping<TKey, T>>;
            /**
            * @description Groups the elements of a sequence according to a specified key selector function and projects the
            *  elements for each group by using a specified selector function. The keys are compared by using the specified
            *  comparer in argument 'equalityComparer' if provided.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.groupby.aspx | MSDN}
            *
            * @param {(item: T) => TKey} keySelector
            * @param {(first: TKey, second: TKey) => boolean} equalityComparer
            * @param {(item: TSource) => TElement} elementSelector?
            *
            * @returns {TS.Linq.Enumerator<TS.Linq.Grouping<TKey, TElement>>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            groupBy<TKey, TElement>(keySelector: (item: T) => TKey, equalityComparer: (first: TKey, second: TKey) => boolean, elementSelector: (item: T) => TElement): TS.Linq.Enumerator<TS.Linq.Grouping<TKey, TElement>>;
            /**
            * @description Correlates the elements of two sequences based on equality of keys and groups the results. The
            *  default equality comparer is used to compare the keys.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534297.aspx | MSDN}
            *
            * @param {Iterable<TInner>} innerEnumerator
            * @param {(outerItem: T) => TKey} outerKeySelector
            * @param {(innerItem: TInner) => TKey} innerKeySelector
            * @param {(outerItem: T, group: Iterable<TInner>) => TResult} resultSelector
            *
            * @returns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            groupJoin<TInner, TKey, TResult>(innerEnumerator: Iterable<TInner>, outerKeySelector: (outerItem: T) => TKey, innerKeySelector: (innerItem: TInner) => TKey, resultSelector: (outerItem: T, group: Iterable<TInner>) => TResult): TS.Linq.Enumerator<TResult>;
            /**
            * @description Correlates the elements of two sequences based on key equality and groups the results. A specified
            *  equalityComparer is used to compare the keys.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb535047.aspx | MSDN}
            *
            * @param {Iterable<TInner>} innerEnumerator
            * @param {(outerItem: T) => TKey} outerKeySelector
            * @param {(innerItem: TInner) => TKey} innerKeySelector
            * @param {(outerItem: T, group: Iterable<TInner>) => TResult} resultSelector
            * @param {(first: TKey, second: TKey) => boolean} equalityComparer
            *
            * @returns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            groupJoin<TInner, TKey, TResult>(innerEnumerator: Iterable<TInner>, outerKeySelector: (outerItem: T) => TKey, innerKeySelector: (innerItem: TInner) => TKey, resultSelector: (outerItem: T, group: Iterable<TInner>) => TResult, equalityComparer: <TKey>(outerKey: TKey, innerKey: TKey) => boolean): TS.Linq.Enumerator<TResult>;
            /**
            * @description Produces the set intersection of two sequences by using the default equality comparer (===) to
            *  compare values.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb460136.aspx | MSDN}
            *
            * @param {Iterable<T>} secondEnumerator
            *
            * @retuns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            intersect(secondEnumerator: Iterable<T>): TS.Linq.Enumerator<T>;
            /**
            * @description Produces the set intersection of two sequences by using the specified equalityComparer to compare
            *  values.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb355408.aspx | MSDN}
            *
            * @param {Iterable<T>} secondEnumerator
            * @param {(first: T, second: T) => boolean} equalityComparer
            *
            * @retuns { TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            intersect(secondEnumerator: Iterable<T>, equalityComparer: (first: T, second: T) => boolean): TS.Linq.Enumerator<T>;
            /**
            * @description Correlates the elements of two sequences based on matching keys.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534675(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<T>} innerEnumerator
            * @param {(outerItem: T) => TKey} outerKeySelector
            * @param {(innerItem: TInner) => TKey} innerKeySelector
            * @param {(outerItem: T, innerItem: TInner) => TResult} resultSelector
            *
            * @retuns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            join<TInner, TKey, TResult>(innerEnumerator: Iterable<TInner>, outerKeySelector: (outerItem: T) => TKey, innerKeySelector: (innerItem: TInner) => TKey, resultSelector: (outerItem: T, innerItem: TInner) => TResult): TS.Linq.Enumerator<TResult>;
            /**
            * @description Returns the last element of a sequence. Returns the last element of a sequence that satisfies the
            *  predicate function if specified.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb549138.aspx | MSDN}
            *
            * @param {(item: T) => boolean} predicate
            *
            * @retuns {T}
            *
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidOperationException}
            */
            last(predicate?: (item: T) => boolean): T;
            /**
            * @description Returns the last element of a sequence, or a default value if the sequence contains no elements.
            *  That function differs from the .NET counterpart in that way that is has a 'defaultConstructorOrValue' in the
            *  signature. That argument is needed because javascript doesn't offer reflection or a type system which you can
            *  rely on at runtime. Hence there is no way to tell which constructor to use for the default when you are
            *  dealing with a complex type or which default value to use when you are dealing with a primitive type. The only
            *  way to make sure that you get the right type at runtime is to place the default constructor or value in the
            *  parameter list of that function.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb301849.aspx | MSDN}
            *
            * @param {{ new (): T; } | T} defaultConstructorOrValue
            *
            * @retuns {T}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            lastOrDefault(defaultConstructorOrValue: {
                new (): T;
            } | T): T;
            /**
            * @description Returns the last element of a sequence that satisfies a specified condition, or a default value if
            *  no such element is found. That function differs from the .NET counterpart in that way that is has a
            *  'defaultConstructorOrValue' in the signature. That argument is needed because javascript doesn't offer
            *  reflection or a type system which you can rely on at runtime. Hence there is no way to tell which constructor
            *  to use for the default when you are dealing with a complex type or which default value to use when you are
            *  dealing with a primitive type. The only way to make sure that you get the right type at runtime is to place
            *  the default constructor or value in the parameter list of that function.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb548915.aspx | MSDN}
            *
            * @param {{ new (): T; } | T} defaultConstructorOrValue
            * @param {(item: T) => boolean } predicate
            *
            * @retuns {T}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            lastOrDefault(defaultConstructorOrValue: {
                new (): T;
            } | T, predicate: (item: T) => boolean): T;
            /**
            * @description Returns the maximum value in a sequence of values.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.max.aspx | MSDN}
            *
            * @retuns {number}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.EmptyEnumerableException}
            */
            max<Number>(): number;
            /**
            * @description Returns the minimum value in a sequence of values.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.min.aspx | MSDN}
            *
            * @retuns {number}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.EmptyEnumerableException}
            */
            min<Number>(): number;
            /**
            * @description Sorts the elements of a sequence in ascending order according to a key.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534966.aspx | MSDN}
            *
            * @param {(item: T) => TKey} keySelector
            *
            * @returns {OrderedEnumerator<T, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            orderBy<TKey>(keySelector: (item: T) => TKey): TS.Linq.OrderedEnumerator<T, TKey>;
            /**
            * @description Sorts the elements of a sequence in ascending order by using a specified comparer and key.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb549422.aspx | MSDN}
            *
            * @param {(item: T) => TKey} keySelector
            * @param {(first: TKey, second: TKey) => number} comparer
            *
            * @returns {OrderedEnumerator<T, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            orderBy<TKey>(keySelector: (item: T) => TKey, comparer: (first: TKey, second: TKey) => number): TS.Linq.OrderedEnumerator<T, TKey>;
            /**
            * @description Sorts the elements of a sequence in descending order according to a key.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534855.aspx | MSDN}
            *
            * @param {(item: T) => TKey} keySelector
            *
            * @returns {OrderedEnumerator<T, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            orderByDescending<TKey>(keySelector: (item: T) => TKey): TS.Linq.OrderedEnumerator<T, TKey>;
            /**
            * @description Sorts the elements of a sequence in descending order by using a specified comparer.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb548916.aspx | MSDN}
            *
            * @param {(item: T) => TKey} keySelector
            * @param {(first: TKey, second: TKey) => number} comparer
            *
            * @returns {OrderedEnumerator<T, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            orderByDescending<TKey>(keySelector: (item: T) => TKey, comparer: (first: TKey, second: TKey) => number): TS.Linq.OrderedEnumerator<T, TKey>;
            /**
            * @description Returns random elements from the base enumeration. This function is not a Linq function. The
            *  function uses a generator to select the current random element. For that reason the function will return as
            *  much elements as required, regardless how much elements the underlying sequence holds.
            *
            *  The function throws a 'TS.Linq.EmptyEnumeratorException' If the underlying sequence is empty.
            *
            *  Attention:
            *  Limit the number of returned elements by calling a 'take' operator or some other limiting operator. Otherwise
            *  you will run out of memory.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @returns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.Linq.EmptyEnumeratorException}
            */
            random(): TS.Linq.Enumerator<T>;
            /**
            * @description Inverts the order of the elements in a sequence.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb358497(v=vs.110).aspx | MSDN}
            *
            * @retuns {TS.Linq.Enumerator<T>}
            *
            */
            reverse(): TS.Linq.Enumerator<T>;
            /**
            * @description Projects each element of a sequence into a new form.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.select(v=vs.110).aspx | MSDN}
            *
            * @param {(item: T) => TResult} selector
            *
            * @retuns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.SelectorException}
            */
            select<TResult>(selector: (item: T) => TResult): TS.Linq.Enumerator<TResult>;
            /**
            * @description Projects each element of a sequence to an Iterable<TSource> and flattens the resulting sequences
            *  into one sequence
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.selectmany(v=vs.110).aspx | MSDN}
            *
            * @param {(item: T) => TResult} selector
            *
            * @retuns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.SelectorException}
            */
            selectMany<TResult>(selector: (item: T) => Iterable<TResult>): TS.Linq.Enumerator<TResult>;
            /**
            * @description Determines whether two sequences are equal by comparing their elements using the default equality
            *  comparer (===).
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb348567.aspx | MSDN}
            *
            * @param {Iterable<T>} secondEnumerator
            *
            * @retuns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            sequenceEqual(secondEnumerator: Iterable<T>): boolean;
            /**
            * @description Determines whether two sequences are equal by comparing their elements using a specified
            *  equalityComparer.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb342073(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<T>} secondEnumerator
            * @param {(first: T, second: T) => boolean} equalityComparer
            *
            * @retuns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            sequenceEqual(secondEnumerator: Iterable<T>, equalityComparer: (first: T, second: T) => boolean): boolean;
            /**
            * @description Creates and returns a new enumerator which holds exact the same elements as the input enumerator
            *  but in randomized order.
            *
            *  This function is not a Linq function.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link http://www.dotnetperls.com/fisher-yates-shuffle}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            */
            shuffle(): TS.Linq.Enumerator<T>;
            /**
            * @description Returns the only element of a sequence, or throws an exception if there is not exactly one element
            *  in the sequence.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb155325.aspx | MSDN }
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @retuns {TSource}
            *
            * @throws {TS.InvalidOperationException}
            * @throws {TS.Linq.MoreThanOneElementException}
            */
            single(): T;
            /**
            * @description Returns the only element of a sequence that satisfies a specified condition or throws an exception
            *  if more than one such elements exists.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb535118.aspx | MSDN }
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => boolean} predicate
            *
            * @returns {TSource}
            *
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.MoreThanOneElementException}
            * @throws {TS.InvalidOperationException}
            */
            single(predicate: (item: T) => boolean): T;
            /**
            * @description Returns the only element of a sequence, or a default value if the sequence is empty. This method
            *  throws an exception if there is more than one element in the sequence. That function differs from the .NET
            *  counterpart in that way that is has a 'defaultConstructorOrValue' in the signature. That argument is needed
            *  because javascript doesn't offer reflection or a type system which you can rely on at runtime. Hence there is
            *  no way to tell which constructor to use for the default when you are dealing with a complex type or which
            *  default value to use when you are dealing with a primitive type. The only way to make sure that you get the
            *  right type at runtime is to place the default constructor or value in the parameter list of that function.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb342451.aspx | MSDN }
            *
            * @param {{ new (): T; } | T} defaultConstructorOrValue
            *
            * @retuns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.Linq.MoreThanOneElementException}
            */
            singleOrDefault(defaultConstructorOrValue: {
                new (): T;
            } | T): T;
            /**
            * @description Returns the only element of a sequence that satisfies a specified condition or a default value if
            *  no such element exists, This method throws an exception if more than one element satisfies the condition. That
            *  function differs from the .NET counterpart in that way that is has a 'defaultConstructorOrValue' in the
            *  signature. That argument is needed because javascript doesn't offer reflection or a type system which you can
            *  rely on at runtime. Hence there is no way to tell which constructor to use for the default when you are
            *  dealing with a complex type or which default value to use when you are dealing with a primitive type. The only
            *  way to make sure that you get the right type at runtime is to place the default constructor or value in the
            *  parameter list of that function.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb549274.aspx | MSDN }
            *
            * @param {{ new (): T; } | T} defaultConstructorOrValue
            * @param {item: TSource) => boolean} predicate
            *
            * @retuns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.MoreThanOneElementException}
            */
            singleOrDefault(defaultConstructorOrValue: {
                new (): T;
            } | T, predicate: (item: T) => boolean): T;
            /**
            * @description Bypasses a specified number of elements in a sequence and returns the remaining elements.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb358985.aspx | MSDN}
            *
            * @paream {number} count
            *
            * @retuns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            skip(count: number): TS.Linq.Enumerator<T>;
            /**
            * @description Bypasses elements in a sequence as long as a specified condition is true and then returns the
            *  remaining elements.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.skipwhile.aspx | MSDN}
            *
            * @param {(item: T) => boolean} predicate
            *
            * @returns {TS.Linq.Enumerator<Te>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            skipWhile(predicate: (item: T) => boolean): TS.Linq.Enumerator<T>;
            /**
            * @description Computes the sum of a sequence of numeric values.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.sum.aspx | MSDN}
            *
            * @retuns {number}
            *
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.EmptyEnumeratorException}
            * @throws {TS.OverflowException}
            */
            sum(): number;
            /**
            * @description Returns a specified number of contiguous elements from the start of a sequence.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/bb503062.aspx | MSDN}
            *
            * @returns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            take(count: number): TS.Linq.Enumerator<T>;
            /**
            * @description Returns elements from a sequence as long as a specified condition is true.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534804.aspx | MSDN}
            *
            * @param { (item: T) => boolean} predicate
            *
            * @returns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            takeWhile(predicate: (item: T) => boolean): TS.Linq.Enumerator<T>;
            /**
            * @description Creates an Array<T> from the list.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb298736 | MSDN}
            *
            * @returns {Array<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            toArray(): Array<T>;
            /**
            * @description Creates a Dictionary<TKey, TSource> from an Iterable<TSource> according to a specified key
            *  selector function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb549277(v=vs.110).aspx | MSDN }
            *
            * @param {Iterable<TSource>} enumerator
            * @param { (item: TSource) => TKey} keySelector
            *
            * @returns {TS.Collections.Dictionary<TKey, TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.ArgumentUndefinedException}
            * @throws {TS.Collections.DuplicateKeyException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidOperationException}
             */
            toDictionary<TKey>(keySelector: (item: T) => TKey): TS.Collections.Dictionary<TKey, T>;
            /**
            * @description Creates a List<TSource> from an Iterable<TSource>. The list will have the 'allowNull' flag set to
            *  true.
            * @description Extension function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb342261(v=vs.110).aspx | MSDN}
            *
            * @returns {TS.Collections.List<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            toList(): TS.Collections.List<T>;
            /**
            * @description Produces the set union of two sequences by using the strict comparison operator (===). This
            *  function may produce results that differ from the C# counterpart, because the comparison operators have
            *  different implementations in C# and javascript.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb341731.aspx | MSDN}
            *
            * @param {Iterable<T>} secondEnumerator
            *
            * @returns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            union(secondEnumerator: Iterable<T>): TS.Linq.Enumerator<T>;
            /**
            * @description Produces the set union of two sequences by using the comparison operator provide in argument
            *  'equalityComparer'.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb358407.aspx | MSDN}
            *
            * @param {Iterable<T>} secondEnumerator
            * @param {(first: T, second: T) => boolean} equalityComparer?
            *
            * @returns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            union(secondEnumerator: Iterable<T>, equalityComparer: (first: T, second: T) => boolean): TS.Linq.Enumerator<T>;
            /**
            * @description Filters a sequence of values based on a predicate.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.where.aspx | MSDN}
            *
            * @param {(item: T) => boolean} predicate
            *
            * @retuns {TS.Linq.Enumerator<T>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            where(predicate: (item: T) => boolean): TS.Linq.Enumerator<T>;
            /**
            * @description Applies a specified function to the corresponding elements of two sequences, producing a sequence
            *  of the results.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/dd267698(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<TSecond>} secondEnum
            * @param {(first: TFirst, second: TSecond) => TResult} func
            *
            * @retuns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            zip<TSecond, TResult>(secondEnum: Iterable<TSecond>, func: (first: T, second: TSecond) => TResult): TS.Linq.Enumerator<TResult>;
        }
    }
    namespace Linq {
        /**
        * @class TS.Linq.Enumerator<T>
        *
        * @descripton  The 'TS.Linq.Enumerator' class is used by the Linq extension functions. The Enumerator class is the
        *  TypeScript equivalent to the ES6 Iteration protocols.
        *
        * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols | MDN}
        *
        * @extends {TS.Linq.BaseEnumerator<T>}
        */
        class Enumerator<T> extends TS.Linq.BaseEnumerator<T> {
            /**
            * @private
            */
            private genFunc;
            /**
            * @description Property which returns an empty 'Enumerator'.
            *
            * @get {Enumerator<any>}
            */
            static readonly Empty: Enumerator<any>;
            /**
            * @description This function returns the Iterator of the current Enumerator as soon as an iteration starts. E.g.
            *  when a 'for ( let x of enumerator)' is called.
            *
            * @implements {BaseEnumerator<T>}
            *
            * @returns {IterableIterator<T>}, An instance of the iterator type.
            */
            [Symbol.iterator](): Iterator<T>;
            /**
            * @constructor
            *
            * @description Creates a new 'TS.Linq.Enumerator<T>' object. Takes a  generator function as source. The
            *  generator creates the elements which get treated as the underlying collection of this enumerator. The
            *  constructor throws an exception if the generator is invalid.
            *
            * @param {() => IterableIterator<T>} generator
            *
            * @throws {TS.InvalidInvocationException}
            * @throws {TS.ArgumentNullOrUndefinedException}
            */
            constructor(generator: () => IterableIterator<T>);
            /**
            * @constructor
            *
            * @description Creates a new 'TS.Linq.Enumerator<T>' object. Takes any iterable object or an array like
            *  object as source. The predicate function defines which element becomes an element of underlying collection of
            *  this enumerator. The constructor throws an exception if the source isn't iterable an array like object or if
            *  the predicate function is invalid.
            *
            * @param {Iterable<T>} source
            * @param {(item: T) => boolean} predicate
            *
            * @throws {TS.InvalidInvocationException}
            * @throws {TS.ArgumentNullOrUndefinedException}
            */
            constructor(source: Iterable<T> | ArrayLike<T>, predicate?: (item: T) => boolean);
        }
    }
    namespace Linq {
        namespace Extensions {
            /**
            * @description Applies an accumulator function over a sequence.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb548651.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(first: TSource, second: TSource) => TSource} accumulator
            *
            * @returns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.Linq.EmptyEnumeratorException}
            * @throws {TS.InvalidTypeException}
            */
            function aggregate<TSource>(enumerator: Iterable<TSource>, accumulator: (first: TSource, second: TSource) => TSource): TSource;
            /**
            * @description Applies an accumulator function over a sequence. The specified seed value is used as the initial
            *  accumulator value.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb549218.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(first: TAccumulate, second: TSource) => TAccumulate} accumulator
            * @param {TAccumulate} seed
            *
            * @returns {TAccumulate}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function aggregate<TSource, TAccumulate>(enumerator: Iterable<TSource>, accumulator: (first: TAccumulate, second: TSource) => TAccumulate, seed: TAccumulate): TAccumulate;
            /**
            * @description Determines whether all elements of a sequence satisfy a condition.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb548541.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => boolean} predicate
            *
            * @returns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function all<TSource>(enumerator: Iterable<TSource>, predicate: (item: TSource) => boolean): boolean;
            /**
            * @description Determines whether a sequence contains any elements.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb337697.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @returns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function any<TSource>(enumerator: Iterable<TSource>): boolean;
            /**
            * @description Determines whether any element of a sequence satisfies a condition.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534972.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => boolean} predicate
            *
            * @returns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function any<TSource>(enumerator: Iterable<TSource>, predicate: (item: TSource) => boolean): boolean;
            /**
            * @description Computes the average of a sequence of number values.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb354760.aspx | MSDN}
            *
            * @param {Iterable<number>} enumerator
            *
            * @returns {number} The average of all items in the enumerable.
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.EmptyEnumeratorException}
            * @throws {TS.OverflowException}
            */
            function average(enumerator: Iterable<number>): number;
            /**
            * @description Concatenates two sequences.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb302894.aspx | MSDN}
            *
            * @param {Iterable<TSource>} firstEnumerator
            * @param {Iterable<TSource>} secondEnumerator
            *
            * @returns { TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}.
            */
            function concat<TSource>(firstEnumerator: Iterable<TSource>, secondEnumerator: Iterable<TSource>): TS.Linq.Enumerator<TSource>;
            /**
            * @description Determines whether a sequence contains a specified element by using the default equality comparer.
            *  Uses javascript strict comparison operator 'strict equality (===)' to determine whether an elements in the
            *  enumeration matches with the specified search element. This function may produce results that differ from the
            *  C# counterpart, because the comparison operators have different implementations in C# and javascript.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb352880.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {TSource} element
            *
            * @returns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function contains<TSource>(enumerator: Iterable<TSource>, element: TSource): boolean;
            /**
            * @description Determines whether a sequence contains a specified element by using the specified equality comparer.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb339118.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {TSource} element
            * @param {(first: TSource, second: TSource) => boolean} equalityComparer
            *
            * @returns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function contains<TSource>(enumerator: Iterable<TSource>, element: TSource, equalityComparer: (first: TSource, second: TSource) => boolean): boolean;
            /**
            * @description Returns the number of elements in a sequence.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.count.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @returns {number}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function count<TSource>(enumerator: Iterable<TSource>): number;
            /**
            * @description Returns a number that represents how many elements in the specified sequence satisfy a condition.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb535181.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => boolean} predicate
            *
            * @returns {number}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function count<TSource>(enumerator: Iterable<TSource>, predicate: (item: TSource) => boolean): number;
            /**
            * @description This function returns an endless number of elements from the underlying sequence by running over
            *  the that sequence in cycles. The function enumerates the elements of the base sequence from the start to then
            *  end and starts over with the first element. This function will never run out of elements. There is one
            *  exception of that rule. If the underlying sequence is an empty sequence, the cycle function will never give a
            *  result.
            *
            *  Attention:
            *  Limit the number of returned elements by calling a 'take' operator or some other limiting operator.
            *  Otherwise you will run out of memory.
            *
            *  This function is not a Linq function.
            * @description Deferred execution.
            *
            * @param  {Iterable<TSource>} enumerator
            *
            * @returns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function cycle<TSource>(enumerator: Iterable<TSource>): TS.Linq.Enumerator<TSource>;
            /**
            * @description Returns the elements of an enumerator, or a default valued singleton collection if the sequence is
            *  empty. That function differs from the .NET counterpart in that way that is has a 'defaultConstructorOrValue'
            *  in the signature. That argument is needed because javascript doesn't offer reflection or a type system which
            *  you can rely on at runtime. Hence there is no way to tell which constructor to use for the default when you
            *  are dealing with a complex type or which default value to use when you are dealing with a primitive type. The
            *  only way to make sure that you get the right type at runtime is to place the default constructor or value in
            *  the parameter list of that function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.defaultifempty.aspx | MSDN}
            *
            * @param  {Iterable<TSource>} enumerator
            * @param  { new (): TSource; } | T) defaultConstructorOrValue
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function defaultIfEmpty<TSource>(enumerator: Iterable<TSource>, defaultConstructorOrValue: {
                new (): TSource;
            } | TSource): TS.Linq.Enumerator<TSource>;
            /**
            * @description Returns distinct elements from a sequence by using the default equality comparer to compare values.
            *  Uses javascript strict comparison operator 'strict equality (===)' to achieve distinction. This function may
            *  produce results that differ from the C# counterpart, because the comparison operators have different
            *  implementations in C# and javascript.
            * @description Deferred execution
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.distinct.aspx | MSDN}
            *
            * @param  {Iterable<TSource>} enumerator
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function distinct<TSource>(enumerator: Iterable<TSource>): TS.Linq.Enumerator<TSource>;
            /**
            * @description Returns distinct elements from a sequence by using a specified equality comparer to compare values.
            * @description Deferred execution
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.distinct.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(first: TSource, second: TSource) => boolean} equalityComparer
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function distinct<TSource>(enumerator: Iterable<TSource>, equalityComparer: (first: TSource, second: TSource) => boolean): TS.Linq.Enumerator<TSource>;
            /**
            * @description Returns the element at a specified index in a sequence.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb299233(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {number} index
            *
            * @retuns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.IndexOutOfRangeException}
            * @throws {TS.InvalidTypeException}
            */
            function elementAt<TSource>(enumerator: Iterable<TSource>, index: number): TSource;
            /**
            * @description Returns the element at a specified index in a sequence or a default value if the index is out of
            *  the range of the sequence. That function differs from the .NET counterpart in that way that is has a
            *  'defaultConstructorOrValue' in the signature. That argument is needed because javascript doesn't offer
            *  reflection or a type system which you can rely on at runtime. Hence there is no way to tell which constructor
            *  to use for the default when you are dealing with a complex type or which default value to use when you are
            *  dealing with a primitive type. The only way to make sure that you get the right type at runtime is to place
            *  the default constructor or value in the parameter list of that function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb494386(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {number} index
            * @param {{ new (): TSource; } | TSource} defaultConstructorOrValue
            *
            * @retuns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function elementAtOrDefault<TSource>(enumerator: Iterable<TSource>, index: number, defaultConstructorOrValue: {
                new (): TSource;
            } | TSource): TSource;
            /**
            * @description Produces the set difference of two sequences. Uses javascript strict comparison operator
            *  'strict equality (===)' to achieve distinction. This function may produce results that differ from the C#
            *  counterpart, because the comparison operators have different implementations in C# and javascript.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb300779.aspx | MSDN}
            *
            * @param {Iterable<TSource>} firstEnumerator
            * @param {Iterable<TSource>} secondEnumerator
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function except<TSource>(firstEnumerator: Iterable<TSource>, secondEnumerator: Iterable<TSource>): TS.Linq.Enumerator<TSource>;
            /**
            * @description Produces the set difference of two sequences by using the specified equality comparer to compare
            *  values.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb336390.aspx | MSDN}
            *
            * @param {Iterable<TSource>} firstEnumerator
            * @param {Iterable<TSource>} secondEnumerator
            * @param {(first: TSource, second: TSource) => boolean)} equalityComparer
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function except<TSource>(firstEnumerator: Iterable<TSource>, secondEnumerator: Iterable<TSource>, equalityComparer: (first: TSource, second: TSource) => boolean): TS.Linq.Enumerator<TSource>;
            /**
            * @description Returns the first element of a sequence.
            * @description Immediate execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.first.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @returns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidOperationException}
            * @throws {TS.InvalidTypeException}
            */
            function first<TSource>(enumerator: Iterable<TSource>): TSource;
            /**
            * @description Returns the first element in a sequence that satisfies a specified condition.
            * @description Immediate execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.first.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => boolean} predicate
            *
            * @returns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidOperationException}
            * @throws {TS.InvalidTypeException}
            */
            function first<TSource>(enumerator: Iterable<TSource>, predicate: (item: TSource) => boolean): TSource;
            /**
            * @description Returns the first element of a sequence, or a default value if the sequence contains no elements.
            *  That function differs from the .NET counterpart in that way that is has a 'defaultConstructorOrValue' in the
            *  singnature. That argument is needed because javascript doesn't offer reflection or a type system which you
            *  can rely on at runtime. Hence there is no way to tell which constructor to use for the default when you are
            *  dealing with a complex type or which default value to use when you are dealing with a primitive type. The only
            *  way to make sure that you get the right type at runtime is to place the default constructor or value in the
            *  parameter list of that function.
            * @description Immediate execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.firstordefault.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {{ new (): TSource; } | TSource} defaultConstructorOrValue
            *
            * @returns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function firstOrDefault<TSource>(enumerator: Iterable<TSource>, defaultConstructorOrValue: {
                new (): TSource;
            } | TSource): TSource;
            /**
            * @description Returns the first element of the sequence that satisfies a condition or a default value if no
            *  element satisfied the condition. That function differs from the .NET counterpart in that way that is has a
            *  'defaultConstructorOrValue' in the signature. That argument is needed because javascript doesn't offer
            *  reflection or a type system which you can rely on at runtime. Hence there is no way to tell which constructor
            *  to use for the default when you are dealing with a complex type or which default value to use when you are
            *  dealing with a primitive type. The only way to make sure that you get the right type at runtime is to place
            *  the default constructor or value in the parameter list of that function.
            * @description Immediate execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.firstordefault.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param { new (): TSource; } | TSource defaultConstructorOrValue
            * @param {(item: TSource) => boolean} predicate
            *
            * @returns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function firstOrDefault<TSource>(enumerator: Iterable<TSource>, defaultConstructorOrValue: {
                new (): TSource;
            } | TSource, predicate: (item: TSource) => boolean): TSource;
            /**
            * @description Performs the specified action on each element of the underlying sequence. I implemented this
            *  extension for your convenience. Without that function you had to call 'toArray' first before you could
            *  use the array method for each. Please read the article below from 'Eric Lippert's' blog to make sure that you
            *  fully understand all the implications of this extension function.
            *
            *  This function is not a Linq function.
            * @description Immediate execution.
            *
            * @see {@link http://blogs.msdn.com/b/ericlippert/archive/2009/05/18/foreach-vs-foreach.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => void } action
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function forEach<TSource>(enumerator: Iterable<TSource>, action: (item: TSource) => void): TS.Linq.Enumerator<TSource>;
            /**
            * @description Groups the elements of a sequence according to a specified key selector function.
            * @description Deferred execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.groupby.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => TKey} keySelector
            *
            * @returns {TS.Linq.Enumerator<TS.Linq.Grouping<TKey, TSource>>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function groupBy<TSource, TKey>(enumerator: Iterable<TSource>, keySelector: (item: TSource) => TKey): TS.Linq.Enumerator<Grouping<TKey, TSource>>;
            /**
            * @description Groups the elements of a sequence according to a specified key selector function.
            *  The keys are compared by using the specified comparer in argument 'equalityComparer'.
            * @description Deferred execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.groupby.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => TKey} keySelector
            * @param {(first: TKey, second: TKey) => boolean} equalityComparer
            *
            * @returns {TS.Linq.Enumerator<TS.Linq.Grouping<TKey, TSource>>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function groupBy<TSource, TKey>(enumerator: Iterable<TSource>, keySelector: (item: TSource) => TKey, equalityComparer: (first: TKey, second: TKey) => boolean): TS.Linq.Enumerator<Grouping<TKey, TSource>>;
            /**
            * @description Groups the elements of a sequence according to a specified key selector function and projects the
            *  elements for each group by using a specified selector function. The keys are compared by using the specified
            *  comparer in argument 'equalityComparer' if provided.
            * @description Deferred execution.
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/system.linq.enumerable.groupby.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => TKey} keySelector
            * @param {(first: TKey, second: TKey) => boolean} equalityComparer
            * @param {(item: TSource) => TElement} elementSelector?
            *
            * @returns {TS.Linq.Enumerator<TS.Linq.Grouping<TKey, TElement>>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function groupBy<TSource, TKey, TElement>(enumerator: Iterable<TSource>, keySelector: (item: TSource) => TKey, equalityComparer: (first: TKey, second: TKey) => boolean, elementSelector: (item: TSource) => TElement): TS.Linq.Enumerator<Grouping<TKey, TElement>>;
            /**
            * @description Correlates the elements of two sequences based on equality of keys and groups the results.
            *  The default equality comparer is used to compare the keys.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534297.aspx | MSDN}
            *
            * @param {Iterable<TOuter>} outerEnumerator
            * @param {Iterable<TInner>} innerEnumerator
            * @param {(outerItem: TOuter) => TKey} outerKeySelector
            * @param {(innerItem: TInner) => TKey} innerKeySelector
            * @param {(outerItem: TOuter, group: Iterable<TInner>) => TResult} resultSelector
            *
            * @returns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function groupJoin<TOuter, TInner, TKey, TResult>(outerEnumerator: Iterable<TOuter>, innerEnumerator: Iterable<TInner>, outerKeySelector: (outerItem: TOuter) => TKey, innerKeySelector: (innerItem: TInner) => TKey, resultSelector: (outerItem: TOuter, group: Iterable<TInner>) => TResult): TS.Linq.Enumerator<TResult>;
            /**
            * @description Correlates the elements of two sequences based on key equality and groups the results.
            *  A specified equalityComparer is used to compare the keys.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb535047.aspx | MSDN}
            *
            * @param {Iterable<TOuter>} outerEnumerator
            * @param {Iterable<TInner>} innerEnumerator
            * @param {(outerItem: TOuter) => TKey} outerKeySelector
            * @param {(innerItem: TInner) => TKey} innerKeySelector
            * @param {(outerItem: TOuter, group: Iterable<TInner>) => TResult} resultSelector
            * @param {(first: TKey, second: TKey) => boolean} equalityComparer
            *
            * @returns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function groupJoin<TOuter, TInner, TKey, TResult>(outerEnumerator: Iterable<TOuter>, innerEnumerator: Iterable<TInner>, outerKeySelector: (outerItem: TOuter) => TKey, innerKeySelector: (innerItem: TInner) => TKey, resultSelector: (outerItem: TOuter, group: Iterable<TInner>) => TResult, equalityComparer: <TKey>(first: TKey, second: TKey) => boolean): TS.Linq.Enumerator<TResult>;
            /**
            * @description Produces the set intersection of two sequences by using the default equality comparer (===) to
            *  compare values.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb460136.aspx | MSDN}
            *
            * @param {Iterable<TSource>} firstEnumerator
            * @param {Iterable<TSource>} secondEnumerator
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function intersect<TSource>(firstEnumerator: Iterable<TSource>, secondEnumerator: Iterable<TSource>): TS.Linq.Enumerator<TSource>;
            /**
            * @description Produces the set intersection of two sequences by using the specified equalityComparer to compare
            *  values.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb355408.aspx | MSDN}
            *
            * @param {Iterable<TSource>} firstEnumerator
            * @param {Iterable<TSource>} secondEnumerator
            * @param {(first: TSource, second: TSource) => boolean} equalityComparer
            *
            * @retuns { TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function intersect<TSource>(firstEnumerator: Iterable<TSource>, secondEnumerator: Iterable<TSource>, equalityComparer: (first: TSource, second: TSource) => boolean): TS.Linq.Enumerator<TSource>;
            /**
            * @description Correlates the elements of two sequences based on matching keys.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534675(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<TOuter>} outerEnumerator
            * @param {Iterable<TInner>} innerEnumerator
            * @param {(outerItem: TOuter) => TKey} outerKeySelector
            * @param {(innerItem: TInner) => TKey} innerKeySelector
            * @param {(outerItem: TOuter, innerItem: TInner) => TResult} resultSelector
            *
            * @retuns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function join<TOuter, TInner, TKey, TResult>(outerEnumerator: Iterable<TOuter>, innerEnumerator: Iterable<TInner>, outerKeySelector: (outerItem: TOuter) => TKey, innerKeySelector: (innerItem: TInner) => TKey, resultSelector: (outerItem: TOuter, innerItem: TInner) => TResult): TS.Linq.Enumerator<TResult>;
            /**
            * @description Returns the last element of a sequence.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb358775.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @retuns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function last<TSource>(enumerator: Iterable<TSource> | OrderedEnumerator<TSource, any>): TSource;
            /**
            * @description Returns the last element of a sequence that satisfies a specified condition.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb549138.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => boolean} predicate
            *
            * @retuns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidOperationException}
            */
            function last<TSource>(enumerator: Iterable<TSource>, predicate: (item: TSource) => boolean): TSource;
            /**
            * @description Returns the last element of a sequence, or a default value if the sequence contains no elements.
            *  That function differs from the .NET counterpart in that way that is has a 'defaultConstructorOrValue' in the
            *  signature. That argument is needed because javascript doesn't offer reflection or a type system which you can
            *  rely on at runtime. Hence there is no way to tell which constructor to use for the default when you are
            *  dealing with a complex type or which default value to use when you are dealing with a primitive type. The only
            *  way to make sure that you get the right type at runtime is to place the default constructor or value in the
            *  parameter list of that function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb301849.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {{ new (): TSource; } | TSource} defaultConstructorOrValue
            *
            * @retuns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function lastOrDefault<TSource>(enumerator: Iterable<TSource>, defaultConstructorOrValue: {
                new (): TSource;
            } | TSource): TSource;
            /**
            * @description Returns the last element of a sequence that satisfies a specified condition, or a default value if
            *  no such element is found. That function differs from the .NET counterpart in that way that is has a
            *  'defaultConstructorOrValue' in the signature. That argument is needed because javascript doesn't offer
            *  reflection or a type system which you can rely on at runtime. Hence there is no way to tell which constructor
            *  to use for the default when you are dealing with a complex type or which default value to use when you are
            *  dealing with a primitive type. The only way to make sure that you get the right type at runtime is to place
            *  the default constructor or value in the parameter list of that function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb548915.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {{ new (): TSource; } | TSource} defaultConstructorOrValue
            * @param {(item: TSource) => boolean } predicate
            *
            * @retuns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function lastOrDefault<TSource>(enumerator: Iterable<TSource>, defaultConstructorOrValue: {
                new (): TSource;
            } | TSource, predicate: (item: TSource) => boolean): TSource;
            /**
            * @description Returns the maximum value in a sequence of values.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.max.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @retuns {number}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.EmptyEnumeratorException}
            */
            function max<Number>(enumerator: Iterable<Number>): number;
            /**
            * @description Invokes a transform function on each element of a sequence and returns the maximum number value.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.max.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @retuns {number}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.EmptyEnumeratorException}
            * @trhows {TS.ArgumentException}
            */
            function max<TSource, Number>(enumerator: Iterable<TSource>, selector: (item: TSource) => number): number;
            /**
            * @description Returns the minimum value in a sequence of values.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.min.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @retuns {number}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.EmptyEnumeratorException}
            */
            function min<Number>(enumerator: Iterable<Number>): number;
            /**
            * @description Invokes a transform function on each element of a sequence and returns the minimum number value.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.min.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @retuns {number}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.EmptyEnumeratorException}
            * @trhows {TS.ArgumentException}
            */
            function min<TSource, Number>(enumerator: Iterable<TSource>, selector: (item: TSource) => number): number;
            /**
            * @description Sorts the elements of a sequence in ascending order according to a key.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534966.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => TKey} keySelector
            *
            * @returns {TS.Linq.OrderedEnumerator<TSource, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function orderBy<TSource, TKey>(enumerator: Iterable<TSource>, keySelector: (item: TSource) => TKey): TS.Linq.OrderedEnumerator<TSource, TKey>;
            /**
            * @description Sorts the elements of a sequence in ascending order by using a specified comparer and key.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb549422.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => TKey} keySelector
            * @param {(first: TKey, second: TKey) => number} comparer
            *
            * @returns {TS.Linq.OrderedEnumerator<TSource, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function orderBy<TSource, TKey>(enumerator: Iterable<TSource>, keySelector: (item: TSource) => TKey, comparer: (first: TKey, second: TKey) => number): TS.Linq.OrderedEnumerator<TSource, TKey>;
            /**
            * @description Sorts the elements of a sequence in descending order according to a key.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534855.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => TKey} keySelector
            *
            * @returns {TS.Linq.OrderedEnumerator<TSource, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function orderByDescending<TSource, TKey>(enumerator: Iterable<TSource>, keySelector: (item: TSource) => TKey): TS.Linq.OrderedEnumerator<TSource, TKey>;
            /**
            * @description Sorts the elements of a sequence in descending order by using a specified comparer.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb548916.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => TKey} keySelector
            * @param {(first: TKey, second: TKey) => number} comparer
            *
            * @returns {TS.Linq.OrderedEnumerator<TSource, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function orderByDescending<TSource, TKey>(enumerator: Iterable<TSource>, keySelector: (item: TSource) => TKey, comparer: (first: TKey, second: TKey) => number): TS.Linq.OrderedEnumerator<TSource, TKey>;
            /**
            * @description Returns random elements from the base enumeration. The function uses a generator to select the
            *  current random element. For that reason the function will return as much elements as required, regardless
            *  how much elements the underlying sequence holds.
            *
            *  The function throws a 'TS.Linq.EmptyEnumeratorException' If the underlying sequence is empty.
            *
            *  Attention:
            *  Limit the number of returned elements by calling a 'take' operator or some other limiting operator.
            *  Otherwise you will run out of memory.
            *
            *
            *  This function is not a Linq function.
            * @description Deferred execution.
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @returns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.EmptyEnumeratorException}
            */
            function random<TSource>(enumerator: Iterable<TSource>): TS.Linq.Enumerator<TSource>;
            /**
            * @description Generates a sequence of integral integer numbers within a specified range.
            * @description Deferred execution
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.range.aspx | MSDN}
            *
            * @param {number} start
            * @param {number} count
            *
            * @retuns {TS.Linq.Enumerator<Number>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.ArgumentOutOfRangeException}
            */
            function range(start: number, count: number): TS.Linq.Enumerator<Number>;
            /**
            * @description Generates a sequence that contains one repeated element as often as specified in count.
            * @description Deferred execution
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb348899(v=vs.110).aspx | MSDN}
            *
            * @param {TSource} element
            * @param {number} count
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.ArgumentUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function repeat<TSource>(element: TSource, count: number): TS.Linq.Enumerator<TSource>;
            /**
            * @description Inverts the order of the elements in a sequence.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb358497(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function reverse<TSource>(enumerator: Iterable<TSource>): TS.Linq.Enumerator<TSource>;
            /**
            * @description Projects each element of a sequence into a new form.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.select(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => TResult} selector
            *
            * @retuns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.SelectorException}
            */
            function select<TSource, TResult>(enumerator: Iterable<TSource>, selector: (item: TSource) => TResult): TS.Linq.Enumerator<TResult>;
            /**
            * @description Projects each element of a sequence to an Iterable<TSource> and flattens the resulting sequences
            *  into one sequence
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.selectmany(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => TResult} selector
            *
            * @retuns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.SelectorException}
            */
            function selectMany<TSource, TResult>(enumerator: Iterable<TSource>, selector: (item: TSource) => Iterable<TResult>): TS.Linq.Enumerator<TResult>;
            /**
            * @description Determines whether two sequences are equal by comparing their elements using the default equality
            *  comparer (===).
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb348567.aspx | MSDN}
            *
            * @param {Iterable<TSource>} firstEnumerator
            * @param {Iterable<TSource>} secondEnumerator
            *
            * @retuns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function sequenceEqual<TSource>(firstEnumerator: Iterable<TSource>, secondEnumerator: Iterable<TSource>): boolean;
            /**
            * @description Determines whether two sequences are equal by comparing their elements using a specified
            *  equalityComparer.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb342073(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<TSource>} firstEnumerator
            * @param {Iterable<TSource>} secondEnumerator
            * @param {(first: TSource, second: TSource) => boolean} equalityComparer
            *
            * @retuns {boolean}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function sequenceEqual<TSource>(firstEnumerator: Iterable<TSource>, secondEnumerator: Iterable<TSource>, equalityComparer: (first: TSource, second: TSource) => boolean): boolean;
            /**
            * @description Creates and returns a new enumerator which holds exact the same elements as the input enumerator
            *  but in randomized order.
            *
            *  This function is not a Linq function.
            * @description Deferred execution.
            *
            * @see {@link http://www.dotnetperls.com/fisher-yates-shuffle : fisher-yates-shuffle @ dotnetperls.com}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function shuffle<TSource>(enumerator: Iterable<TSource>): TS.Linq.Enumerator<TSource>;
            /**
            * @description Returns the only element of a sequence, or throws an exception if there is not exactly one element
            *  in the sequence.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb155325.aspx | MSDN }
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @retuns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.MoreThanOneElementException}
            * @throws {TS.InvalidOperationException}
            */
            function single<TSource>(enumerator: Iterable<TSource>): TSource;
            /**
            * @description Returns the only element of a sequence that satisfies a specified condition or throws an exception
            *  if more than one such elements exists.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb535118.aspx | MSDN }
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => boolean} predicate
            *
            * @returns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.MoreThanOneElementException}
            * @throws {TS.InvalidOperationException}
            */
            function single<TSource>(enumerator: Iterable<TSource>, predicate: (item: TSource) => boolean): TSource;
            /**
            * @description Returns the only element of a sequence, or a default value if the sequence is empty. This method
            *  throws an exception if there is more than one element in the sequence. That function differs from the .NET
            *  counterpart in that way that is has a 'defaultConstructorOrValue' in the signature. That argument is needed
            *  because javascript doesn't offer reflection or a type system which you can rely on at runtime. Hence there is
            *  no way to tell which constructor to use for the default when you are dealing with a complex type or which
            *  default value to use when you are dealing with a primitive type. The only way to make sure that you get the
            *  right type at runtime is to place the default constructor or value in the parameter list of that function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb342451.aspx | MSDN }
            *
            * @param {Iterable<TSource>} enumerator
            * @param {{ new (): TSource; } | TSource} defaultConstructorOrValue
            *
            * @retuns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.MoreThanOneElementException}
            */
            function singleOrDefault<TSource>(enumerator: Iterable<TSource>, defaultConstructorOrValue: {
                new (): TSource;
            } | TSource): TSource;
            /**
            * @description Returns the only element of a sequence that satisfies a specified condition or a default value if
            *  no such element exists, This method throws an exception if more than one element satisfies the condition. That
            *  function differs from the .NET counterpart in that way that is has a 'defaultConstructorOrValue' in the
            *  signature. That argument is needed because javascript doesn't offer reflection or a type system which you can
            *  rely on at runtime. Hence there is no way to tell which constructor to use for the default when you are
            *  dealing with a complex type or which default value to use when you are dealing with a primitive type. The only
            *  way to make sure that you get the right type at runtime is to place the default constructor or value in the
            *  parameter list of that function.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb549274.aspx | MSDN }
            *
            * @param {Iterable<TSource>} enumerator
            * @param {{ new (): TSource; } | TSource} defaultConstructorOrValue
            * @param {item: TSource) => boolean} predicate
            *
            * @retuns {TSource}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.MoreThanOneElementException}
            */
            function singleOrDefault<TSource>(enumerator: Iterable<TSource>, defaultConstructorOrValue: {
                new (): TSource;
            } | TSource, predicate: (item: TSource) => boolean): TSource;
            /**
            * @description Bypasses a specified number of elements in a sequence and returns the remaining elements.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb358985.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @paream {number} count
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function skip<TSource>(enumerator: Iterable<TSource>, count: number): TS.Linq.Enumerator<TSource>;
            /**
            * @description Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.skipwhile.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => boolean} predicate
            *
            * @returns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function skipWhile<TSource>(enumerator: Iterable<TSource>, predicate: (item: TSource) => boolean): TS.Linq.Enumerator<TSource>;
            /**
            * @description Computes the sum of a sequence of numeric values.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.sum.aspx | MSDN}
            *
            * @param {Iterable<number>} enumerator
            *
            * @retuns {number}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.Linq.EmptyEnumeratorException}
            * @throws {TS.OverflowException}
            */
            function sum(enumerator: Iterable<number>): number;
            /**
            * @description Returns a specified number of contiguous elements from the start of a sequence.
            * @description Deferred execution
            *
            * @see {@link http://msdn.microsoft.com/en-us/library/bb503062.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @returns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function take<TSource>(enumerator: Iterable<TSource>, count: number): TS.Linq.Enumerator<TSource>;
            /**
            * @description Returns elements from a sequence as long as a specified condition is true.
            * @description Deferred execution
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534804.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param { (item: TSource) => boolean} predicate
            *
            * @returns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function takeWhile<TSource>(enumerator: Iterable<TSource>, predicate: (item: TSource) => boolean): TS.Linq.Enumerator<TSource>;
            /**
            * @description Performs a subsequent ordering of the elements in a sequence in ascending order according to a key.
            *  This function uses a default comparer. The result may differ from the C# counterpart
            *  because of the different implementations of the default comparer.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534743.aspx | MSDN}
            *
            * @param {TS.Linq.IOrderedEnumerator<TSource>} enumerator
            * @param { (item: TSource) => TKey } keySelector
            *
            * @returns {TS.Linq.OrderedEnumerator<TSource, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function thenBy<TSource, TKey>(enumerator: TS.Linq.IOrderedEnumerator<TSource>, keySelector: (item: TSource) => TKey): TS.Linq.OrderedEnumerator<TSource, TKey>;
            /**
            * @description Performs a subsequent ordering of the elements in a sequence in ascending order by using a specified comparer.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534500.aspx | MSDN}
            *
            * @param {TS.Linq.IOrderedEnumerator<TSource>} enumerator
            * @param { (item: TSource) => TKey } keySelector
            * @param {(first: TKey, second: TKey) => number} comparer
            *
            * @returns {TS.Linq.OrderedEnumerator<TSource, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function thenBy<TSource, TKey>(enumerator: TS.Linq.IOrderedEnumerator<TSource>, keySelector: (item: TSource) => TKey, comparer: (first: TKey, second: TKey) => number): TS.Linq.OrderedEnumerator<TSource, TKey>;
            /**
            * @description Performs a subsequent ordering of the elements in a sequence in descending order, according to
            *  the specified key. This function uses a default comparer. The result may differ from the C# counterpart
            *  because of the different implementations of the default comparer.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534736.aspx | MSDN}
            *
            * @param {TS.Linq.IOrderedEnumerator<TSource>} enumerator
            * @param { (item: TSource) => TKey } keySelector
            *
            * @returns {TS.Linq.OrderedEnumerator<TSource, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function thenByDescending<TSource, TKey>(enumerator: TS.Linq.IOrderedEnumerator<TSource>, keySelector: (item: TSource) => TKey): TS.Linq.OrderedEnumerator<TSource, TKey>;
            /**
            * @description Performs a subsequent ordering of the elements in a sequence in descending order, according to the specified key and comparer.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534489.aspx | MSDN}
            *
            * @param {TS.Linq.IOrderedEnumerator<TSource>} enumerator
            * @param { (item: TSource) => TKey } keySelector
            * @param {(first: TKey, second: TKey) => number} comparer
            *
            * @returns {TS.Linq.OrderedEnumerator<TSource, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function thenByDescending<TSource, TKey>(enumerator: TS.Linq.IOrderedEnumerator<TSource>, keySelector: (item: TSource) => TKey, comparer: (first: TKey, second: TKey) => number): TS.Linq.OrderedEnumerator<TSource, TKey>;
            /**
            * @description Creates an Array<TSource> from an Iterable<TSource>
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb298736 | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            *
            * @returns {Array<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function toArray<TSource>(enumerator: Iterable<TSource>): Array<TSource>;
            /**
            * @description Creates a Dictionary<TKey, TSource> from an Iterable<TSource> according to a specified key selector function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb549277(v=vs.110).aspx | MSDN }
            *
            * @param {Iterable<TSource>} enumerator
            * @param { (item: TSource) => TKey} keySelector
            *
            * @returns {TS.Collections.Dictionary<TKey, TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.ArgumentUndefinedException}
            * @throws {TS.Collections.DuplicateKeyException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidOperationException}
            */
            function toDictionary<TSource, TKey>(enumerator: Iterable<TSource>, keySelector: (item: TSource) => TKey): TS.Collections.Dictionary<TKey, TSource>;
            /**
            * @description Creates a List<TSource> from an Iterable<TSource>. The list will have the 'allowNull' flag set to true.
            * @description Immediate execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb342261(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @returns {TS.Collections.List<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function toList<TSource>(enumerator: Iterable<TSource>): TS.Collections.List<TSource>;
            /**
            * @description Produces the set union of two sequences by using the strict comparison operator (===).
            *  This function may produce results that differ from the C# counterpart, because the comparison operators have different
            *  implementations in C# and javascript.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb341731.aspx | MSDN}
            *
            * @param {Iterable<TSource>} firstEnumerator
            * @param {Iterable<TSource>} secondEnumerator
            *
            * @returns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function union<TSource>(firstEnumerator: Iterable<TSource>, secondEnumerator: Iterable<TSource>): TS.Linq.Enumerator<TSource>;
            /**
            * @description Produces the set union of two sequences by using the comparison operator provide in argument 'equalityComparer'.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb358407.aspx | MSDN}
            *
            * @param {Iterable<TSource>} firstEnumerator
            * @param {Iterable<TSource>} secondEnumerator
            * @param {(first: TSource, second: TSource) => boolean} equalityComparer?
            *
            * @returns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function union<TSource>(firstEnumerator: Iterable<TSource>, secondEnumerator: Iterable<TSource>, equalityComparer: (first: TSource, second: TSource) => boolean): TS.Linq.Enumerator<TSource>;
            /**
            * @description Filters a sequence of values based on a predicate.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/system.linq.enumerable.where.aspx | MSDN}
            *
            * @param {Iterable<TSource>} enumerator
            * @param {(item: TSource) => boolean} predicate
            *
            * @retuns {TS.Linq.Enumerator<TSource>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function where<TSource>(enumerator: Iterable<TSource>, predicate: (item: TSource) => boolean): TS.Linq.Enumerator<TSource>;
            /**
            * @description Applies a specified function to the corresponding elements of two sequences, producing a sequence of the results.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/dd267698(v=vs.110).aspx | MSDN}
            *
            * @param {Iterable<TFirst>} firstEnum
            * @param {Iterable<TSecond>} secondEnum
            * @param {(first: TFirst, second: TSecond) => TResult} func
            *
            * @retuns {TS.Linq.Enumerator<TResult>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            function zip<TFirst, TSecond, TResult>(firstEnum: Iterable<TFirst>, secondEnum: Iterable<TSecond>, func: (first: TFirst, second: TSecond) => TResult): TS.Linq.Enumerator<TResult>;
        }
    }
    namespace Linq {
        /**
        * interface TS.Linq.IOrderedEnumerator<T>
        */
        interface IOrderedEnumerator<T> {
            /**
            * @returns {Iterator<Iterator<T>}
            */
            partitionIterator(): Iterator<Iterator<T>>;
        }
    }
    namespace Linq {
        /**
        * @class TS.Linq.OrderedEnumerator<T, TKey>
        *
        * @description The 'TS.Linq.OrderedEnumerator' class is used by the Linq sort functions where every subsequent call
        *  to a sort function operate on the partitions of the enumerator elements without changing the order of previous
        *  sorting.
        *
        * @implements {BaseEnumerator<T}
        * @implements {TS.Linq.IOrderedEnumerator<T>}
        */
        class OrderedEnumerator<T, TKey> extends BaseEnumerator<T> implements TS.Linq.IOrderedEnumerator<T> {
            /**
            * @private
            */
            private keySelector;
            /**
            * @private
            */
            private comparer;
            /**
            * @private
            */
            private orderedEnumerator;
            /**
            * @description Property which returns an empty 'OrderedEnumerator'.
            *
            * @get {TS.Liny.OrderedEnumerator<any, any>} Empty
            */
            static readonly Empty: OrderedEnumerator<any, any>;
            /**
            * @implements {TS.Linq.BaseEnumerator<T>}
            *
            * @returns {Iterator<T>}, An instance of the iterator type.
            */
            [Symbol.iterator](): Iterator<T>;
            /**
            * @implements {TS.Linq.IOrderedEnumerator<T>}
            *
            * @returns {Iterator<Iterator<T>}, An instance of the partitioned iterator type.
            */
            partitionIterator(): Iterator<Iterator<T>>;
            /**
            * @private
            *
            * @param { Iterator<Iterator<T>>} partitionIterator
            *
            * @returns Array<T>
            */
            private flatPartitions(partitionIterator);
            /**
            * @constructor
            *
            * @param {Iterable<T> | IOrderedEnumerator<T>} enumerator
            * @param {(item: T) => TKey} keySelector
            * @param {(first: TKey, second: TKey) => number} comparer
            *
            * @throws {TS.InvalidTypeException}
            * @throws {TS.ArgumentNullOrUndefinedException}
            */
            constructor(enumerator: Iterable<T> | IOrderedEnumerator<T>, keySelector: (item: T) => TKey, comparer: (first: TKey, second: TKey) => number);
            /**
            * @description Performs a subsequent ordering of the elements in a sequence in ascending order according to a key.
            *  This function uses a default comparer. The result may differ from the C# counterpart
            *  because of the different implementations of the default comparer.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534743.aspx | MSDN}
            *
            * @param { (item: T) => TKey } keySelector
            *
            * @returns {TS.Linq.OrderedEnumerator<T, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            thenBy<TKey>(keySelector: (item: T) => TKey): TS.Linq.OrderedEnumerator<T, TKey>;
            /**
            * @description Performs a subsequent ordering of the elements in a sequence in ascending order by using a specified comparer.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534500.aspx | MSDN}
            *
            * @param { (item: T) => TKey } keySelector
            * @param {(first: TKey, second: TKey) => number} comparer
            *
            * @returns {TS.Linq.OrderedEnumerator<T, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            thenBy<TKey>(keySelector: (item: T) => TKey, comparer: (first: TKey, second: TKey) => number): TS.Linq.OrderedEnumerator<T, TKey>;
            /**
            * @description Performs a subsequent ordering of the elements in a sequence in descending order, according to
            *  the specified key. This function uses a default comparer. The result may differ from the C# counterpart
            *  because of the different implementations of the default comparer.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534736.aspx | MSDN}
            *
            * @param { (item: T) => TKey } keySelector
            *
            * @returns {TS.Linq.OrderedEnumerator<T, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            thenByDescending<TKey>(keySelector: (item: T) => TKey): TS.Linq.OrderedEnumerator<T, TKey>;
            /**
            * @description Performs a subsequent ordering of the elements in a sequence in descending order, according to the
            *  specified key and comparer.
            * @description Extension function.
            * @description Deferred execution.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb534489.aspx | MSDN}
            *
            * @param { (item: T) => TKey } keySelector
            * @param {(first: TKey, second: TKey) => number} comparer
            *
            * @returns {TS.Linq.OrderedEnumerator<T, TKey>}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            thenByDescending<TKey>(keySelector: (item: T) => TKey, comparer: (first: TKey, second: TKey) => number): TS.Linq.OrderedEnumerator<T, TKey>;
        }
    }
    namespace Linq {
        /**
        * @interface TS.Linq.IGrouping<TKey, T>
        */
        interface IGrouping<TKey, T> {
            /**
            * @readonly
            */
            key: TKey;
        }
        /**
        * @class TS.Linq.Grouping<TKey, T>
        *
        * @description This class is an extension of the TS.Linq.Enumerator<T> class and is the returned type of the
        *  TS.Linq.Extensions.groupBy function.
        *
        * @extends {TS.Linq.Enumerator<T>}
        *
        * @implements {TS.Linq.IGrouping<TKey, T>}
        */
        class Grouping<TKey, T> extends TS.Linq.Enumerator<T> implements TS.Linq.IGrouping<TKey, T> {
            private innerKey;
            /**
            * @implements {TS.Linq.IGrouping<TKey, T>}
            *
            * @get {TKey} key
            */
            readonly key: TKey;
            /**
            * @constructor
            *
            * @param {TKey} key
            * @param {Iterable<T>} enumerator
            * @param {(item: T) => TKey} keySelector
            * @param {(first: TKey, second: TKey) => boolean} equalityComparer
            * @param {(item: T) => any} elementSelector?
            *
            * @throws {TS.InvalidTypeException}
            * @throws {TS.ArgumentNullOrUndefinedException}
            */
            constructor(key: TKey, enumerator: Iterable<T>, keySelector: (item: T) => TKey, equalityComparer: (first: TKey, second: TKey) => boolean, elementSelector?: (item: T) => any);
        }
    }
    namespace Collections {
        /**
        * @class TS.Collections.DuplicateKeyException
        *
        * @description This exception signals a duplicate key in a collection.
        *
        * @extends {TS.Exception}
        */
        class DuplicateKeyException extends TS.Exception {
            /**
            * @override {TS.Exception}
            *
            * @get {string} type
            */
            readonly type: string;
            /**
            * @constructor
            *
            * @param {string} message.
            * @param {TS.Exception} innerException?, optional inner exception.
            */
            constructor(message?: string, innerException?: Exception);
        }
        /**
        * @class TS.Collections.InvalidKeyException
        *
        * @description This exception signals a general problem with a key of a collection.
        *
        * @extends {TS.Exception}
        */
        class InvalidKeyException extends TS.Exception {
            /**
            * @private
            */
            private internalKeyValue;
            /**
            * @override {TS.Exception}
            *
            * @get {string} type
            */
            readonly type: string;
            /**
            * @get {any} keyValue
            */
            readonly keyValue: any;
            /**
            * @constructor
            *
            * @param {any} keyValue
            * @param {string} message?, optional message.
            * @param {TS.Exception} innerException?, optional inner exception.
            */
            constructor(keyValue: any, message?: string, innerException?: Exception);
        }
    }
    namespace Collections {
        /**
        * @class TS.Collections.KeyValuePair<TKey, TValue>
        *
        * @description This is the implementation of the key value pair used by the dictionary class.
        *
        * @see {@link https://msdn.microsoft.com/en-us/library/5tbh8a42(v=vs.110).aspx | MSDN}
        */
        class KeyValuePair<TKey, TValue> {
            /**
            * @private
            */
            private internalKey;
            /**
            * @private
            */
            private internalValue;
            /**
            * @get {TKey} key
            */
            readonly key: TKey;
            /**
            * @get {TValue} value
            */
            readonly value: TValue;
            /**
            * @constructor
            *
            * @param {TKey} key.
            * @param {TValue} value
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            */
            constructor(key: TKey, value: TValue);
        }
    }
    namespace Collections {
        /**
        * @interface TS.Collections.IDictionary<TKey, TValue>
        *
        * @description Represents a generic collection of key/value pairs.
        *
        * @see {@link https://msdn.microsoft.com/en-us/library/s4ys34ea(v=vs.110).aspx | MSDN}
        *
        * @extends {TS.Collections.ICollection<TS.Collections.KeyValuePair<TKey, TValue>>}
        */
        interface IDictionary<TKey, TValue> extends TS.Collections.ICollection<TS.Collections.KeyValuePair<TKey, TValue>> {
            /**
            * @description Adds an item to the ICollection<T>.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/63ywd54z(v=vs.110).aspx | MSDN }
            *
            * @implements {TS.Collections.ICollection<TS.Collections.KeyValuePair<TKey, TValue>>}
            *
            * @param {TS.Collections.KeyValuePair<TKey, TValue>} item
            *
            * @returns {this}
            */
            add(item: KeyValuePair<TKey, TValue>): this;
            /**
            * @description Adds an element with the provided key and value to the IDictionary<TKey, TValue>.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/cy7xta5e(v=vs.110).aspx | MSDN }
            *
            * @param {TKey} key
            * @param {TValue} value
            *
            * @returns {this}
            */
            add(key: TKey, value: TValue): this;
            /**
            * @description Determines whether the ICollection<TS.Collections.KeyValuePair<TKey, TValue>> contains a specific
            *  value.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/k5cf1d56(v=vs.110).aspx | MSDN }
            *
            * @implements {TS.Collections.ICollection<TS.Collections.KeyValuePair<TKey, TValue>>}
            *
            * @returns {boolean}
            */
            contains(item: TS.Collections.KeyValuePair<TKey, TValue>): boolean;
            /**
            * @description Determines whether the IDictionary<TKey, TValue> contains an element with the specified key.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/htszx2dy(v=vs.110).aspx | MSDN }
            *
            * @param {TKey} key
            *
            * @returns {boolean}
            */
            containsKey(key: TKey): boolean;
            /**
            * @description Determines whether the IDictionary<TKey, TValue> contains an element with the specified value.
            *  There is no equivalent function defined in the C# counterpart of the IDictionary interface.
            *
            * @param {TValue} value
            *
            * @returns {boolean}
            */
            containsValue(value: TValue): boolean;
            /**
            * @description Determines whether the IDictionary<TKey, TValue> contains an element with the specified value.
            *  Using the specified equalityComparer to compare the values.
            *  There is no equivalent function defined in the C# counterpart of the IDictionary interface.
            *
            * @param {TValue} value
            * @param {(first: TValue, second: TValue) => boolean} equalityComparer
            *
            * @returns {boolean}
            */
            containsValue(value: TValue, equalityComparer: (first: TValue, second: TValue) => boolean): boolean;
            /**
            * @description Copies the elements of the ICollection<T> to an Array, starting at the specified array index.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/0efx51xw(v=vs.110).aspx | MSDN }
            *
            * @implements {TS.Collections.ICollection<TS.Collections.KeyValuePair<TKey, TValue>>}
            *
            * @param {Array<KeyValuePair<TKey, TValue>>} targetArray
            * @param {number} destIndex, Default value is 0.
            *
            * @returns {TS.Collections.IDictionary<TKey, TValue>}
            */
            copyTo(targetArray: Array<KeyValuePair<TKey, TValue>>, destIndex?: number): this;
            /**
            * @description Returns the item with the specified key from the IDictionary<TKey, TValue>. Returns a undefined
            *  value if the dictionary doesn't contain an item with the specified key. This function is a substitute for the
            *  'item[key]' property defined in the .NET 'IDictionary<TKey, TValue> Interface'.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/s4ys34ea(v=vs.110).aspx | MSDN }
            *
            * @param {TKey} key
            *
            * @returns {TS.Collections.KeyValuePair<TKey, TValue> | undefined}
            */
            getItem(key: TKey): TS.Collections.KeyValuePair<TKey, TValue> | undefined;
            /**
            * @description Returns the value associated with the specified key or undefined if there is no match for the
            *  specified key. This function is a substitute for the 'item[key]' property defined in the .NET
            *  'IDictionary<TKey, TValue> Interface'.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/s4ys34ea(v=vs.110).aspx | MSDN }
            *
            * @param {TKey} key
            *
            * @returns {TValue | undefined}
            */
            getValue(key: TKey): TValue | undefined;
            /**
            * @description Returns a TS.Linq.Enumerable<TKey> containing the keys of the IDictionary<TKey, TValue>.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/1ebzfbyx(v=vs.110).aspx | MSDN }
            *
            * @get {TS.Linq.Enumerator<TKey>} keys
            */
            keys: TS.Linq.Enumerator<TKey>;
            /**
            * @description Removes the occurrence of the specific item from the IDictionary<TKey, TValue>. The function fails
            *  silent if the dictionary doesn't contain that item.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bye7h94w(v=vs.110).aspx | MSDN }
            *
            * @implements {TS.Collections.ICollection<TS.Collections.KeyValuePair<TKey, TValue>>}
            *
            * @param {TS.Collections.KeyValuePair<TKey, TValue>} item
            *
            * @returns {this}
            */
            remove(item: TS.Collections.KeyValuePair<TKey, TValue>): this;
            /**
            * @description Removes the element with the specified key from the IDictionary<TKey, TValue>. The function fails
            *  silent if the dictionary doesn't contain an item with specified key.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/k8s489f0(v=vs.110).aspx | MSDN }
            *
            * @param {TKey} key
            *
            * @returns {this}
            */
            remove(key: TKey): this;
            /**
            * @description Sets the value of argument 'newValue' to the item with the specified key in the dictionary. This
            *  function is a substitute for the 'item[key]' property defined in the .NET 'IDictionary<TKey, TValue>
            *  Interface'.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/zyxt2e2h(v=vs.110).aspx | MSDN }
            *
            * @param {TKey} key
            * @param {TValue} newValue
            *
            * @returns {TS.Collections.IDictionary<TKey, TValue>}
            */
            setItem(key: TKey, newValue: TValue): this;
            /**
            * @description Converts the ICollection<T> into an array of type T. (Inherited from ICollection<T>.) There is no
            *  equivalent function defined in the C# counterpart of the IDictionary interface.
            *
            * @implements {TS.Collections.ICollection<TS.Collections.KeyValuePair<TKey, TValue>>}
            *
            * @returns {Array<TS.Collections.KeyValuePair<TKey, TValue>>}
            */
            toArray(): Array<TS.Collections.KeyValuePair<TKey, TValue>>;
            /**
            * @description Returns a TS.Linq.Enumerable<TValue> containing the values in the IDictionary<TKey, TValue>.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/0yxt5h4s(v=vs.110).aspx | MSDN }
            *
            * @get {TS.Linq.Enumerator<TValue>} values
            */
            values: TS.Linq.Enumerator<TValue>;
        }
    }
    namespace Collections {
        /**
        * @interface TS.Collections.ICollection<T>
        *
        * @description Defines methods to manipulate generic collections.
        *
        * @see {@link https://msdn.microsoft.com/en-us/library/92t2ye13(v=vs.110).aspx | MSDN}
        */
        interface ICollection<T> {
            /**
            * @description Adds items to the ICollection<T>. Differs from the C# counterpart in that way, that you are
            *  allowed to add multiple items at once.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/63ywd54z(v=vs.110).aspx | MSND }
            *
            * @param {Array<T>} ...item
            *
            * @returns {this}
            */
            add(...item: Array<T>): this;
            /**
            * @description Removes all items from the ICollection<T>.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/5axy4fbh(v=vs.110).aspx | MSND }
            *
            * @returns {this}
            */
            clear(): this;
            /**
            * @description Determines whether the ICollection<T> contains a specific value.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/k5cf1d56(v=vs.110).aspx | MSND }
            *
            * @param {T} item
            *
            * @returns {boolean}
            */
            contains(item: T): boolean;
            /**
            * @description Copies the elements of the ICollection<T> to an Array, starting at the specified array index or at
            *  positions 0 if no array index is specified.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/0efx51xw(v=vs.110).aspx | MSND }
            *
            * @param {Array<T>} targetArray.
            * @param {number} destIndex?, Default value is 0.
            *
            * @returns {this}
            */
            copyTo(targetArray: Array<T>, destIndex?: number): this;
            /**
            * @description Gets the number of elements contained in the ICollection<T>.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/5s3kzhec(v=vs.110).aspx | MSND }
            *
            * @returns {number}
            */
            count(): number;
            /**
            * @description Removes the first occurrence of the specific object from the ICollection<T>.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bye7h94w(v=vs.110).aspx | MSND }
            *
            * @param {T} item
            *
            * @returns {this}
            */
            remove(item: T): this;
            /**
            * @description Converts the ICollection<T> into an array of type T. There is no equivalent function defined in
            *  the C# counterpart of the ICollection<T> interface.
            *
            * @returns {Array<T>}
            */
            toArray(): Array<T>;
        }
    }
    namespace Collections {
        /**
        * @interface TS.Collections.IList<T>
        *
        * @description Interface which must be implemented by all list classes.
        *
        * @extends {TS.Collections.ICollection<T>}
        *
        * @see {@link https://msdn.microsoft.com/en-us/library/5y536ey6(v=vs.110).aspx | MSDN}
        */
        interface IList<T> extends TS.Collections.ICollection<T> {
            /**
            * @description Specified whether null values are allowed in the IList<T> or not. This flag is set during
            *  construction and can't be changed during the lifetime of the instance.
            *
            * @readonly
            *
            * @member {boolean} allowNull.
            */
            allowNull: boolean;
            /**
            * @description Determines the index of a specific item in the IList<T>. If startIndex is set, the search for the
            *  item starts at the specified startIndex. Otherwise the search starts at the default position 0. If a comparer
            *  is specified, this comparer is used to decide whether a list element is a match with the search element or
            *  not. If the comparer isn't specified, the default equality comparer '===' is used. The function returns -1 if
            *   there is no match for the given item.
            *
            * @param {T} item.
            * @param {number} startIndex?, Default = 0.
            * @param {(first: T, second: T) => boolean} equalityComparer, Default = "===".
            *
            * @returns {number}
            */
            indexOf(item: T, startIndex?: number, equalityComparer?: (first: T, second: T) => boolean): number;
            /**
            * @descripton Inserts an item to the IList<T> at the specified index.
            *
            * @param {number} index.
            * @param {T} value.
            *
            * @returns {this}
            */
            insert(index: number, value: T): this;
            /**
            * @description Removes the item at the specified index from the IList<T>.
            *
            * @param {number} index.
            *
            * @returns {this}
            */
            removeAt(index: number): this;
        }
    }
    namespace Collections {
        /**
        * @class TS.Collections.List<T>
        *
        * @description This class  mimics the .NET counterpart of a List<T> as far as possible in TypeScript.
        *
        * @see {@link https://msdn.microsoft.com/en-us/library/s6hkc2c4(v=vs.110).aspx | MSDN}
        *
        * @implements {TS.Collections.IList<T>}
        * @implements {ArrayLike<T>}
        * @extends {TS.Linq.BaseEnumerator<T>}
        */
        class List<T> extends TS.Linq.BaseEnumerator<T> implements TS.Collections.IList<T>, ArrayLike<T> {
            /**
            * @private
            */
            private internalAllowNull;
            /**
            * @implements  {ArrayLike<T>}
            *
            * @returns {T}
            */
            [index: number]: T;
            /**
            * @implements  {ArrayLike<T>}
            *
            * @returns {number}
            */
            length: number;
            /**
            * @implements  {TS.Linq.BaseEnumerator<T>}
            *
            * @returns {Iterator<TSource>}
            */
            [Symbol.iterator](): Iterator<T>;
            /**
            * @description Adds items to the IList<T>.
            *
            * @implements {TS.Collections.IList<T>}
            *
            * @param {Array<T>} ...item
            *
            * @returns {this}
            *
            * @throws {TS.ArgumentUndefinedException}
            * @throws {TS.InvalidTypeExceptionn}
            */
            add(...rest: Array<T>): this;
            /**
            * @description Signals whether the list accepts null values as elements or not.
            *
            * @implements {TS.Collections.IList<T>}
            *
            * @get {boolean} allowNull
            */
            readonly allowNull: boolean;
            /**
            * @description Removes all items from the IList<T>.
            *
            * @implements {TS.Collections.IList<T>}
            *
            * @returns {this}
            */
            clear(): this;
            /**
            * @description Copies the elements of the IList<T> to an Array, starting at a particular Array index.
            *
            * @implements {TS.Collections.IList<T>}
            *
            * @param {Array<T>} targetArray.
            * @param {number} destIndex?, default value is 0.
            *
            * @returns {this}
            *
            * @throws {TS.ArgumentOutOfRangeException}
            * @throws {TS.ArgumentNullOrUndefinedException};
            * @throws {TS.InvalidTypeException};
            */
            copyTo(targetArray: Array<T>, destIndex?: number): this;
            /**
            * @description Searches for the specified object and returns the zero - based index of the first occurrence
            *  within the entire List<T>. Returns -1 if there is no match for the given item.
            *
            * @implements  {TS.Collections.IList<T>}
            *
            * @param {T} item.
            *
            * @returns {number}
            *
            * @throws {TS.ArgumentUndefinedException}
            * @throws {TS.ArgumentNullOrUndefinedException}
            */
            indexOf(item: T): number;
            /**
            * @description Searches for the specified object and returns the zero - based index of the first occurrence
            *  within the range of elements in the List<T> that extends from the specified index to the last element. Returns
            * -1 if there is no match for the given item.
            *
            * @implements  {TS.Collections.IList<T>}
            *
            * @param {T} item
            * @param {number} startIndex
            *
            * @returns {number}
            *
            * @throws {TS.ArgumentUndefinedException}
            *`@throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            indexOf(item: T, startIndex: number): number;
            /**
            * @description Searches for the specified object and returns the zero - based index of the first occurrence
            *  within the range of elements in the List<T> that extends from the specified index to the last element. The
            *  equalityComparer is used to determine a match with the searched item in the List<T>. Returns -1 if there is no
            *  match for the given item.
            *
            * @implements  {TS.Collections.IList<T>}
            *
            * @param {T} item
            * @param {number} startIndex
            * @param {(first: T, second: T) => boolean} equalityComparer
            *
            * @returns {number}
            *
            * @throws {TS.ArgumentUndefinedException}
            *`@throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            indexOf(item: T, startIndex: number, equalityComparer: (first: T, second: T) => boolean): number;
            /**
            * @descriptiong Inserts an element into the List<T> at the specified index.
            *
            * @implements  {TS.Collections.IList<T>}
            *
            * @param {number} index
            * @param {T} item
            *
            * @returns {this}
            *
            * @throws {TS.ArgumentUndefinedException}
            *`@throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            * @throws {TS.ArgumentOutOfRangeException}
            */
            insert(index: number, item: T): this;
            /**
            * @description Removes the first occurrence of the specified item from the IList<T>.
            *
            * @implements {TS.Collections.IList<T>}
            *
            * @param {T} item
            *
            * @returns {this}
            *
            * @throws {TS.ArgumentUndefinedException}
            */
            remove(item: T): this;
            /**
            * @description Removes the element at the specified index from the IList<T>.
            *
            * @implements {TS.Collections.IList<T>}
            *
            * @param {number} index
            *
            * @returns {this}
            */
            removeAt(index: number): this;
            /**
            * @constructor
            *
            * @description Creates a new List<T>. Requires the allowNull flag to be set which determines whether the null
            *  values will be allowed as element or not. In C# you would declare a List<T> to allow null by choosing a
            *  nullable type as concrete type parameter. Since all types in JavaScript nullable per default, I had to
            *  introduce the 'allowNull' flag in the constructor signature.
            *  The optional generator function will be use to initially fill the list with elements if provided.
            *
            * @param {boolean}, allowNull = true
            * @param{() => IterableIterator<T>} generator?
            *
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidInvocationException}
            */
            constructor(allowNull: boolean, generator?: () => IterableIterator<T>);
            /**
            * @constructor
            *
            * @description Creates a new List<T>. Requires the allowNull flag to be set which determines whether the null
            *  values will be allowed as element or not. In C# you would declare a List<T> to allow null by choosing a
            *  nullable type as concrete type parameter. Since all types in JavaScript nullable per default, I had to
            *  introduce the 'allowNull' flag in the constructor signature.
            *  The optional source will be use to initially fill the list with elements if provided.
            *  The optional predicate determines which elements of the source will become elements of the list.
            *
            * @param {boolean}, allowNull = true
            * @param{Iterable<T> | ArrayLike<T>} source?
            *
            * @throws {TS.InvalidTypeException}
            * @throws {TS.InvalidInvocationException}
            */
            constructor(allowNull: boolean, source?: Iterable<T> | ArrayLike<T>, predicate?: (item: T) => boolean);
            /**
            * @descriptions Adds the element provided in argument 'item' to the end of the list.
            *
            * @private
            */
            private push(item);
            /**
            * @description Returns the last element in the list or undefined if the list is empty.
            *
            * @private
            *
            * @returns {T | undefined}
            */
            private pop();
        }
    }
    namespace Collections {
        /**
        * @class TS.Collections.Dictionary<TKey, TValue>
        *
        * @description This class is an implementation of the IDictionary<TKey, TValue> interface and TypeScript
        *  counterpart of the .NET Dictionary<TKey, TValue> class. Some methods of this class behave different than the C#
        *  counterpart, some are new and some C# methods are not implemented. Those differences are mainly caused by the
        *  javascript limitations. Read the method descriptions to learn more about the variations.
        *
        * @see {@link https://msdn.microsoft.com/en-us/library/xfhwa508(v=vs.110).aspx | MSDN}
        *
        * @extends {TS.Linq.BaseEnumerator<KeyValuePair<TKey, TValue>>}
        *
        * @implements {TS.Collections.IDictionary<TKey, TValue>}
        *
        */
        class Dictionary<TKey, TValue> extends TS.Linq.BaseEnumerator<KeyValuePair<TKey, TValue>> implements TS.Collections.IDictionary<TKey, TValue> {
            /**
            * @private
            */
            private dictionaryMap;
            /**
            * @private
            */
            private keyEqualityComparer;
            /**
            * @private
            */
            private genFunc;
            /**
            * @implements {TS.Linq.BaseEnumerator<KeyValuePair<TKey, TValue>>}
            *
            * @returns {Iterator<KeyValuePair<TKey, TValue>>}
            */
            [Symbol.iterator](): Iterator<KeyValuePair<TKey, TValue>>;
            /**
            * @description Adds an item to the ICollection<T>. There is no equivalent function in the C# dictionary
            *  implementation.
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TS.Collections.KeyValuePair<TKey, TValue>} item
            *
            * @returns {TS.Collections.ICollection<TS.Collections.KeyValuePair<TKey, TValue>>}
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.ArgumentUndefinedException
            * @throws TS.ArgumentNullException;
            * @throws TS.InvalidTypeException
            * @throws TS.Collections.DuplicateKeyException
            */
            add(item: KeyValuePair<TKey, TValue>): this;
            /**
            * @description Adds an element with the provided key and value to the IDictionary<TKey, TValue>.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb338565(v=vs.110).aspx | MSDN  }
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TKey} key
            * @param {TValue} value
            *
            * @returns {this}
            *
            * @throws TS.ArgumentNullOrUndefinedException
            * @throws TS.ArgumentUndefinedException
            * @throws TS.ArgumentNullException;
            * @throws TS.Collections.DuplicateKeyException
            */
            add(key: TKey, value: TValue): this;
            /**
            * @description Removes all items from the dictionary.
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/b5txwy7s(v=vs.110).aspx | MSDN }
            *
            * @returns {this}
            */
            clear(): this;
            /**
            * @description Determines whether the collection contains a specific KeyValuePair. Using the default comparer to
            *  compare the values.
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TS.Collections.KeyValuePair<TKey, TValue>} item
            *
            * @returns {boolean}
            */
            contains(item: TS.Collections.KeyValuePair<TKey, TValue>): boolean;
            /**
            * @description Determines whether the collection contains a specific KeyValuePair. Using the specified
            *  equalityComparer to compare the values. There is no equivalent function in the C# dictionary implementation
            *  which allows to override the default equality comparer for value comparison.
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TS.Collections.KeyValuePair<TKey, TValue>} item
            * @param {(first: TValue, second: TValue) => boolean} equalityComparer
            *
            * @returns {boolean}
            */
            contains(item: TS.Collections.KeyValuePair<TKey, TValue>, equalityComparer: (first: TValue, second: TValue) => boolean): boolean;
            /**
            * @description Determines whether the collection contains a specific key.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/kw5aaea4(v=vs.110).aspx  | MSDN }
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TKey} key
            *
            * @returns {boolean}
            */
            containsKey(key: TKey): boolean;
            /**
            * @description Determines whether the IDictionary<TKey, TValue> contains an element with the specified value.
            *  Using the default comparer to compare the values.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/a63811ah(v=vs.110).aspx  | MSDN }
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TValue} value
            *
            * @returns {boolean}
            */
            containsValue(value: TValue): boolean;
            /**
            * @description Determines whether the IDictionary<TKey, TValue> contains an element with the specified value.
            *  Using the specified equalityComparer to compare the values. There is no equivalent function in the C#
            *  dictionary implementation which allows to override the default equality comparer for value comparison.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/a63811ah(v=vs.110).aspx  | MSDN }
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TValue} value
            * @param {(first: TValue, second: TValue) => boolean} equalityComparer
            *
            * @returns {boolean}
            *
            * @throws {TS.InvalidTypeException}
            */
            containsValue(value: TValue, equalityComparer: (first: TValue, second: TValue) => boolean): boolean;
            /**
            * @description Copies the elements of the dictionary to an Array, starting at the specified array index.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/mt481485(v=vs.110).aspx | MSDN }
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {Array<KeyValuePair<TKey, TValue>>} targetArray
            * @param {number} destIndex, Default value is 0.
            *
            * @returns {this}
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            copyTo(targetArray: Array<KeyValuePair<TKey, TValue>>, destIndex?: number): this;
            /**
            * @description Returns the number of key/value pairs contained in the Dictionary<TKey, TValue>.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/zhcy256f(v=vs.110).aspx | MSDN }
            *
            * @implements {TS.Collection.ICollection<KeyValuePair<TKey, TValue>>}
            *
            * @override {TS.Linq.BaseEnumerator<KeyValuePair<TKey, TValue>>}
            *
            * @returns {number}
            */
            count(): number;
            /**
            * @description Returns the item with the specified key from the Dictionary<TKey, TValue>. Returns an undefined
            *  value if the dictionary doesn't contain an item with the specified key. There is no equivalent method in the
            *  C# dictionary implementation.
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TKey} key.
            *
            * @returns {TS.Collections.KeyValuePair<TKey, TValue> | undefined}
            */
            getItem(key: TKey): TS.Collections.KeyValuePair<TKey, TValue> | undefined;
            /**
            * @description Returns the value of the item with the specified key from the Dictionary<TKey, TValue>. Returns an
            *  undefined value if the dictionary doesn't contain an item with the specified key. This method is a substitute
            *  for the index access implemented in the C# dictionary. In TypeScript you can only crate indexers for strings
            *  or numbers. But a dictionary key can have any type. So there is no other way than creating a set and get
            *  function as a substitute.
            *
            * @see {TS.Collections.Dictionary.setItem}
            * @see {@link https://msdn.microsoft.com/en-us/library/zyxt2e2h(v=vs.110).aspx | MSDN }
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TKey} key
            *
            * @returns {TValue | undefined}
            */
            getValue(key: TKey): TValue | undefined;
            /**
            * @description Gets a TS.Linq.Enumerator<TKey> containing the keys of the IDictionary<TKey, TValue>.
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/yt2fy5zk(v=vs.110).aspx | MSDN }
            *
            * @get {TS.Linq.Enumerator<TKey>} keys
            */
            readonly keys: TS.Linq.Enumerator<TKey>;
            /**
            * @description Removes a key and value from the dictionary.
            *  This method uses the equality comparer which was set in the constructor or the dictionary to determine
            *  equality for the key. This method uses either the default equality comparer to determine equality for the
            *  value or the one you can specify in the optional 'equalityComparer' argument. This function differs from the
            *  C# implementation in multiple ways.
            *
            *  1) This method returns a this reference and not a boolean value.
            *
            *  2) You can specify an equality comparer for value comparison to override the default behavior.
            *
            *  3) This method fails silent if the specified item can't be located in the dictionary.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/cc672341(v=vs.110).aspx | MSDN }
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TS.Collections.KeyValuePair<TKey, TValue>} item
            * @param {(value: TValue) => boolean} equalityComparer?
            *
            * @returns {this}
            *
            * @throws {ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidTypeException}
            */
            remove(item: TS.Collections.KeyValuePair<TKey, TValue>, equalityComparer?: (first: TValue, second: TValue) => boolean): this;
            /**
            * @description Removes the element with the specified key from the IDictionary<TKey, TValue>.
            *  This function differs from the C# implementation in multiple ways.
            *
            *  1) This method returns a this reference and not a boolean value.
            *
            *  2) This method fails silent if the specified key can't be located in the dictionary.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/bb356469(v=vs.110).aspx | MSDN }
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TKey} key
            *
            * @returns {this}
            *
            * @throws {ArgumentNullOrUndefinedException}
            */
            remove(key: TKey): this;
            /**
            * @description Sets the value of argument 'newValue' to the item with the specified key in the dictionary. This
            *  method is a substitute for the index access implemented in the C# dictionary. In TypeScript you can only
            *  create indexers for strings or numbers. But a dictionary key can have any type. So there is no other way than
            *  creating a set and get function as a substitute.
            *
            * @see {TS.Collections.Dictionary.getValue}
            * @see {@link https://msdn.microsoft.com/en-us/library/zyxt2e2h(v=vs.110).aspx | MSDN }
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @param {TKey} key
            * @param {TValue} newValue
            *
            * @returns {this}
            *
            * @throws {TS.Collections.InvalidKeyException}
            */
            setItem(key: TKey, newValue: TValue): this;
            /**
            * @description Converts the ICollection<T> into an array of type  Array<TS.Collections.KeyValuePair<TKey, TValue>>.
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @override {TS.Linq.BaseEnumerator<KeyValuePair<TKey, TValue>>}
            *
            * @returns {Array<TS.Collections.KeyValuePair<TKey, TValue>>}
            */
            toArray(): Array<TS.Collections.KeyValuePair<TKey, TValue>>;
            /**
            * @description Gets a TS.Linq.Enumerator<TValue> containing the values in the IDictionary<TKey, TValue>.
            *
            * @see {@link https://msdn.microsoft.com/en-us/library/ekcfxy3x(v=vs.110).aspx | MSDN }
            *
            * @implements {TS.Collections.IDictionary<TKey, TValue>}
            *
            * @get {TS.Linq.Enumerator<TValue>} values
            */
            readonly values: TS.Linq.Enumerator<TValue>;
            /**
            * @constructor
            *
            * @description Creates a new instance of the  TS.Collections.Dictionary<TKey, TValue> class. Creates a shallow
            *  copy of the iterable 'KeyValuePair' source if provided. Uses the default equality comparer (===) for the key
            *  comparsion if there isn't a key equality comparer provided in argument 'keyEqualityComparer'.
            *
            * @param (Iterable<TS.Collections.KeyValuePair<TKey, TValue>>} source?
            * @param {(first: TKey, second: TKey) => boolean} keyEqualityComparer?
            *
            * @throws {TS.ArgumentNullOrUndefinedException}
            * @throws {TS.InvalidOperationException}
            * @throws {TS.InvalidTypeException}
            */
            constructor(source?: Iterable<TS.Collections.KeyValuePair<TKey, TValue>>, keyEqualityComparer?: (first: TKey, second: TKey) => boolean);
        }
    }
}
